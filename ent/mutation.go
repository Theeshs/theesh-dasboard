// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"theedashboard/ent/education"
	"theedashboard/ent/email"
	"theedashboard/ent/experience"
	"theedashboard/ent/predicate"
	"theedashboard/ent/repository"
	"theedashboard/ent/skill"
	"theedashboard/ent/user"
	"theedashboard/ent/userproject"
	"theedashboard/ent/userservice"
	"theedashboard/ent/userskillassociation"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAlembicVersion       = "AlembicVersion"
	TypeEducation            = "Education"
	TypeEmail                = "Email"
	TypeExperience           = "Experience"
	TypeRepository           = "Repository"
	TypeSkill                = "Skill"
	TypeUser                 = "User"
	TypeUserProject          = "UserProject"
	TypeUserService          = "UserService"
	TypeUserSkillAssociation = "UserSkillAssociation"
)

// AlembicVersionMutation represents an operation that mutates the AlembicVersion nodes in the graph.
type AlembicVersionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AlembicVersion, error)
	predicates    []predicate.AlembicVersion
}

var _ ent.Mutation = (*AlembicVersionMutation)(nil)

// alembicversionOption allows management of the mutation configuration using functional options.
type alembicversionOption func(*AlembicVersionMutation)

// newAlembicVersionMutation creates new mutation for the AlembicVersion entity.
func newAlembicVersionMutation(c config, op Op, opts ...alembicversionOption) *AlembicVersionMutation {
	m := &AlembicVersionMutation{
		config:        c,
		op:            op,
		typ:           TypeAlembicVersion,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAlembicVersionID sets the ID field of the mutation.
func withAlembicVersionID(id string) alembicversionOption {
	return func(m *AlembicVersionMutation) {
		var (
			err   error
			once  sync.Once
			value *AlembicVersion
		)
		m.oldValue = func(ctx context.Context) (*AlembicVersion, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AlembicVersion.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAlembicVersion sets the old AlembicVersion of the mutation.
func withAlembicVersion(node *AlembicVersion) alembicversionOption {
	return func(m *AlembicVersionMutation) {
		m.oldValue = func(context.Context) (*AlembicVersion, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AlembicVersionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AlembicVersionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AlembicVersion entities.
func (m *AlembicVersionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AlembicVersionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AlembicVersionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AlembicVersion.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the AlembicVersionMutation builder.
func (m *AlembicVersionMutation) Where(ps ...predicate.AlembicVersion) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AlembicVersionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AlembicVersionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AlembicVersion, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AlembicVersionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AlembicVersionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AlembicVersion).
func (m *AlembicVersionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AlembicVersionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AlembicVersionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AlembicVersionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown AlembicVersion field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlembicVersionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AlembicVersion field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AlembicVersionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AlembicVersionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AlembicVersionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown AlembicVersion numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AlembicVersionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AlembicVersionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AlembicVersionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AlembicVersion nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AlembicVersionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown AlembicVersion field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AlembicVersionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AlembicVersionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AlembicVersionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AlembicVersionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AlembicVersionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AlembicVersionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AlembicVersionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AlembicVersion unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AlembicVersionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AlembicVersion edge %s", name)
}

// EducationMutation represents an operation that mutates the Education nodes in the graph.
type EducationMutation struct {
	config
	op                Op
	typ               string
	id                *uint
	institue_name     *string
	start_date        *time.Time
	end_date          *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	mode_of_study     *string
	degree_type       *string
	area_of_study     *string
	currenty_studying *bool
	description       *string
	clearedFields     map[string]struct{}
	user              *uint
	cleareduser       bool
	done              bool
	oldValue          func(context.Context) (*Education, error)
	predicates        []predicate.Education
}

var _ ent.Mutation = (*EducationMutation)(nil)

// educationOption allows management of the mutation configuration using functional options.
type educationOption func(*EducationMutation)

// newEducationMutation creates new mutation for the Education entity.
func newEducationMutation(c config, op Op, opts ...educationOption) *EducationMutation {
	m := &EducationMutation{
		config:        c,
		op:            op,
		typ:           TypeEducation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEducationID sets the ID field of the mutation.
func withEducationID(id uint) educationOption {
	return func(m *EducationMutation) {
		var (
			err   error
			once  sync.Once
			value *Education
		)
		m.oldValue = func(ctx context.Context) (*Education, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Education.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEducation sets the old Education of the mutation.
func withEducation(node *Education) educationOption {
	return func(m *EducationMutation) {
		m.oldValue = func(context.Context) (*Education, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EducationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EducationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Education entities.
func (m *EducationMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EducationMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EducationMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Education.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInstitueName sets the "institue_name" field.
func (m *EducationMutation) SetInstitueName(s string) {
	m.institue_name = &s
}

// InstitueName returns the value of the "institue_name" field in the mutation.
func (m *EducationMutation) InstitueName() (r string, exists bool) {
	v := m.institue_name
	if v == nil {
		return
	}
	return *v, true
}

// OldInstitueName returns the old "institue_name" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldInstitueName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstitueName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstitueName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstitueName: %w", err)
	}
	return oldValue.InstitueName, nil
}

// ResetInstitueName resets all changes to the "institue_name" field.
func (m *EducationMutation) ResetInstitueName() {
	m.institue_name = nil
}

// SetStartDate sets the "start_date" field.
func (m *EducationMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *EducationMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *EducationMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *EducationMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *EducationMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *EducationMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[education.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *EducationMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[education.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *EducationMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, education.FieldEndDate)
}

// SetUserID sets the "user_id" field.
func (m *EducationMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *EducationMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *EducationMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[education.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *EducationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[education.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *EducationMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, education.FieldUserID)
}

// SetCreatedAt sets the "created_at" field.
func (m *EducationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EducationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EducationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[education.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EducationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[education.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EducationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, education.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EducationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EducationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EducationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[education.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EducationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[education.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EducationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, education.FieldUpdatedAt)
}

// SetModeOfStudy sets the "mode_of_study" field.
func (m *EducationMutation) SetModeOfStudy(s string) {
	m.mode_of_study = &s
}

// ModeOfStudy returns the value of the "mode_of_study" field in the mutation.
func (m *EducationMutation) ModeOfStudy() (r string, exists bool) {
	v := m.mode_of_study
	if v == nil {
		return
	}
	return *v, true
}

// OldModeOfStudy returns the old "mode_of_study" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldModeOfStudy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModeOfStudy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModeOfStudy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModeOfStudy: %w", err)
	}
	return oldValue.ModeOfStudy, nil
}

// ResetModeOfStudy resets all changes to the "mode_of_study" field.
func (m *EducationMutation) ResetModeOfStudy() {
	m.mode_of_study = nil
}

// SetDegreeType sets the "degree_type" field.
func (m *EducationMutation) SetDegreeType(s string) {
	m.degree_type = &s
}

// DegreeType returns the value of the "degree_type" field in the mutation.
func (m *EducationMutation) DegreeType() (r string, exists bool) {
	v := m.degree_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDegreeType returns the old "degree_type" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDegreeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDegreeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDegreeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDegreeType: %w", err)
	}
	return oldValue.DegreeType, nil
}

// ResetDegreeType resets all changes to the "degree_type" field.
func (m *EducationMutation) ResetDegreeType() {
	m.degree_type = nil
}

// SetAreaOfStudy sets the "area_of_study" field.
func (m *EducationMutation) SetAreaOfStudy(s string) {
	m.area_of_study = &s
}

// AreaOfStudy returns the value of the "area_of_study" field in the mutation.
func (m *EducationMutation) AreaOfStudy() (r string, exists bool) {
	v := m.area_of_study
	if v == nil {
		return
	}
	return *v, true
}

// OldAreaOfStudy returns the old "area_of_study" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldAreaOfStudy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAreaOfStudy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAreaOfStudy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreaOfStudy: %w", err)
	}
	return oldValue.AreaOfStudy, nil
}

// ResetAreaOfStudy resets all changes to the "area_of_study" field.
func (m *EducationMutation) ResetAreaOfStudy() {
	m.area_of_study = nil
}

// SetCurrentyStudying sets the "currenty_studying" field.
func (m *EducationMutation) SetCurrentyStudying(b bool) {
	m.currenty_studying = &b
}

// CurrentyStudying returns the value of the "currenty_studying" field in the mutation.
func (m *EducationMutation) CurrentyStudying() (r bool, exists bool) {
	v := m.currenty_studying
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentyStudying returns the old "currenty_studying" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldCurrentyStudying(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentyStudying is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentyStudying requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentyStudying: %w", err)
	}
	return oldValue.CurrentyStudying, nil
}

// ClearCurrentyStudying clears the value of the "currenty_studying" field.
func (m *EducationMutation) ClearCurrentyStudying() {
	m.currenty_studying = nil
	m.clearedFields[education.FieldCurrentyStudying] = struct{}{}
}

// CurrentyStudyingCleared returns if the "currenty_studying" field was cleared in this mutation.
func (m *EducationMutation) CurrentyStudyingCleared() bool {
	_, ok := m.clearedFields[education.FieldCurrentyStudying]
	return ok
}

// ResetCurrentyStudying resets all changes to the "currenty_studying" field.
func (m *EducationMutation) ResetCurrentyStudying() {
	m.currenty_studying = nil
	delete(m.clearedFields, education.FieldCurrentyStudying)
}

// SetDescription sets the "description" field.
func (m *EducationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EducationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Education entity.
// If the Education object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EducationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *EducationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[education.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *EducationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[education.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *EducationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, education.FieldDescription)
}

// ClearUser clears the "user" edge to the User entity.
func (m *EducationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[education.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *EducationMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *EducationMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *EducationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the EducationMutation builder.
func (m *EducationMutation) Where(ps ...predicate.Education) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EducationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EducationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Education, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EducationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EducationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Education).
func (m *EducationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EducationMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.institue_name != nil {
		fields = append(fields, education.FieldInstitueName)
	}
	if m.start_date != nil {
		fields = append(fields, education.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, education.FieldEndDate)
	}
	if m.user != nil {
		fields = append(fields, education.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, education.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, education.FieldUpdatedAt)
	}
	if m.mode_of_study != nil {
		fields = append(fields, education.FieldModeOfStudy)
	}
	if m.degree_type != nil {
		fields = append(fields, education.FieldDegreeType)
	}
	if m.area_of_study != nil {
		fields = append(fields, education.FieldAreaOfStudy)
	}
	if m.currenty_studying != nil {
		fields = append(fields, education.FieldCurrentyStudying)
	}
	if m.description != nil {
		fields = append(fields, education.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EducationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case education.FieldInstitueName:
		return m.InstitueName()
	case education.FieldStartDate:
		return m.StartDate()
	case education.FieldEndDate:
		return m.EndDate()
	case education.FieldUserID:
		return m.UserID()
	case education.FieldCreatedAt:
		return m.CreatedAt()
	case education.FieldUpdatedAt:
		return m.UpdatedAt()
	case education.FieldModeOfStudy:
		return m.ModeOfStudy()
	case education.FieldDegreeType:
		return m.DegreeType()
	case education.FieldAreaOfStudy:
		return m.AreaOfStudy()
	case education.FieldCurrentyStudying:
		return m.CurrentyStudying()
	case education.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EducationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case education.FieldInstitueName:
		return m.OldInstitueName(ctx)
	case education.FieldStartDate:
		return m.OldStartDate(ctx)
	case education.FieldEndDate:
		return m.OldEndDate(ctx)
	case education.FieldUserID:
		return m.OldUserID(ctx)
	case education.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case education.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case education.FieldModeOfStudy:
		return m.OldModeOfStudy(ctx)
	case education.FieldDegreeType:
		return m.OldDegreeType(ctx)
	case education.FieldAreaOfStudy:
		return m.OldAreaOfStudy(ctx)
	case education.FieldCurrentyStudying:
		return m.OldCurrentyStudying(ctx)
	case education.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Education field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case education.FieldInstitueName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstitueName(v)
		return nil
	case education.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case education.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case education.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case education.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case education.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case education.FieldModeOfStudy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModeOfStudy(v)
		return nil
	case education.FieldDegreeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDegreeType(v)
		return nil
	case education.FieldAreaOfStudy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreaOfStudy(v)
		return nil
	case education.FieldCurrentyStudying:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentyStudying(v)
		return nil
	case education.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EducationMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EducationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EducationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Education numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EducationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(education.FieldEndDate) {
		fields = append(fields, education.FieldEndDate)
	}
	if m.FieldCleared(education.FieldUserID) {
		fields = append(fields, education.FieldUserID)
	}
	if m.FieldCleared(education.FieldCreatedAt) {
		fields = append(fields, education.FieldCreatedAt)
	}
	if m.FieldCleared(education.FieldUpdatedAt) {
		fields = append(fields, education.FieldUpdatedAt)
	}
	if m.FieldCleared(education.FieldCurrentyStudying) {
		fields = append(fields, education.FieldCurrentyStudying)
	}
	if m.FieldCleared(education.FieldDescription) {
		fields = append(fields, education.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EducationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EducationMutation) ClearField(name string) error {
	switch name {
	case education.FieldEndDate:
		m.ClearEndDate()
		return nil
	case education.FieldUserID:
		m.ClearUserID()
		return nil
	case education.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case education.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case education.FieldCurrentyStudying:
		m.ClearCurrentyStudying()
		return nil
	case education.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Education nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EducationMutation) ResetField(name string) error {
	switch name {
	case education.FieldInstitueName:
		m.ResetInstitueName()
		return nil
	case education.FieldStartDate:
		m.ResetStartDate()
		return nil
	case education.FieldEndDate:
		m.ResetEndDate()
		return nil
	case education.FieldUserID:
		m.ResetUserID()
		return nil
	case education.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case education.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case education.FieldModeOfStudy:
		m.ResetModeOfStudy()
		return nil
	case education.FieldDegreeType:
		m.ResetDegreeType()
		return nil
	case education.FieldAreaOfStudy:
		m.ResetAreaOfStudy()
		return nil
	case education.FieldCurrentyStudying:
		m.ResetCurrentyStudying()
		return nil
	case education.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Education field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EducationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, education.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EducationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case education.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EducationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EducationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EducationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, education.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EducationMutation) EdgeCleared(name string) bool {
	switch name {
	case education.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EducationMutation) ClearEdge(name string) error {
	switch name {
	case education.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Education unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EducationMutation) ResetEdge(name string) error {
	switch name {
	case education.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Education edge %s", name)
}

// EmailMutation represents an operation that mutates the Email nodes in the graph.
type EmailMutation struct {
	config
	op              Op
	typ             string
	id              *uint
	call_back_email *string
	message         *string
	name            *string
	subject         *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Email, error)
	predicates      []predicate.Email
}

var _ ent.Mutation = (*EmailMutation)(nil)

// emailOption allows management of the mutation configuration using functional options.
type emailOption func(*EmailMutation)

// newEmailMutation creates new mutation for the Email entity.
func newEmailMutation(c config, op Op, opts ...emailOption) *EmailMutation {
	m := &EmailMutation{
		config:        c,
		op:            op,
		typ:           TypeEmail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailID sets the ID field of the mutation.
func withEmailID(id uint) emailOption {
	return func(m *EmailMutation) {
		var (
			err   error
			once  sync.Once
			value *Email
		)
		m.oldValue = func(ctx context.Context) (*Email, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Email.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmail sets the old Email of the mutation.
func withEmail(node *Email) emailOption {
	return func(m *EmailMutation) {
		m.oldValue = func(context.Context) (*Email, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Email entities.
func (m *EmailMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Email.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCallBackEmail sets the "call_back_email" field.
func (m *EmailMutation) SetCallBackEmail(s string) {
	m.call_back_email = &s
}

// CallBackEmail returns the value of the "call_back_email" field in the mutation.
func (m *EmailMutation) CallBackEmail() (r string, exists bool) {
	v := m.call_back_email
	if v == nil {
		return
	}
	return *v, true
}

// OldCallBackEmail returns the old "call_back_email" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCallBackEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallBackEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallBackEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallBackEmail: %w", err)
	}
	return oldValue.CallBackEmail, nil
}

// ResetCallBackEmail resets all changes to the "call_back_email" field.
func (m *EmailMutation) ResetCallBackEmail() {
	m.call_back_email = nil
}

// SetMessage sets the "message" field.
func (m *EmailMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *EmailMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ClearMessage clears the value of the "message" field.
func (m *EmailMutation) ClearMessage() {
	m.message = nil
	m.clearedFields[email.FieldMessage] = struct{}{}
}

// MessageCleared returns if the "message" field was cleared in this mutation.
func (m *EmailMutation) MessageCleared() bool {
	_, ok := m.clearedFields[email.FieldMessage]
	return ok
}

// ResetMessage resets all changes to the "message" field.
func (m *EmailMutation) ResetMessage() {
	m.message = nil
	delete(m.clearedFields, email.FieldMessage)
}

// SetName sets the "name" field.
func (m *EmailMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailMutation) ResetName() {
	m.name = nil
}

// SetSubject sets the "subject" field.
func (m *EmailMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailMutation) ResetSubject() {
	m.subject = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EmailMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[email.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EmailMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[email.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, email.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Email entity.
// If the Email object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EmailMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[email.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EmailMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[email.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, email.FieldUpdatedAt)
}

// Where appends a list predicates to the EmailMutation builder.
func (m *EmailMutation) Where(ps ...predicate.Email) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Email, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Email).
func (m *EmailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.call_back_email != nil {
		fields = append(fields, email.FieldCallBackEmail)
	}
	if m.message != nil {
		fields = append(fields, email.FieldMessage)
	}
	if m.name != nil {
		fields = append(fields, email.FieldName)
	}
	if m.subject != nil {
		fields = append(fields, email.FieldSubject)
	}
	if m.created_at != nil {
		fields = append(fields, email.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, email.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case email.FieldCallBackEmail:
		return m.CallBackEmail()
	case email.FieldMessage:
		return m.Message()
	case email.FieldName:
		return m.Name()
	case email.FieldSubject:
		return m.Subject()
	case email.FieldCreatedAt:
		return m.CreatedAt()
	case email.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case email.FieldCallBackEmail:
		return m.OldCallBackEmail(ctx)
	case email.FieldMessage:
		return m.OldMessage(ctx)
	case email.FieldName:
		return m.OldName(ctx)
	case email.FieldSubject:
		return m.OldSubject(ctx)
	case email.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case email.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Email field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case email.FieldCallBackEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallBackEmail(v)
		return nil
	case email.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case email.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case email.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case email.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case email.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Email numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(email.FieldMessage) {
		fields = append(fields, email.FieldMessage)
	}
	if m.FieldCleared(email.FieldCreatedAt) {
		fields = append(fields, email.FieldCreatedAt)
	}
	if m.FieldCleared(email.FieldUpdatedAt) {
		fields = append(fields, email.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailMutation) ClearField(name string) error {
	switch name {
	case email.FieldMessage:
		m.ClearMessage()
		return nil
	case email.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case email.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Email nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailMutation) ResetField(name string) error {
	switch name {
	case email.FieldCallBackEmail:
		m.ResetCallBackEmail()
		return nil
	case email.FieldMessage:
		m.ResetMessage()
		return nil
	case email.FieldName:
		m.ResetName()
		return nil
	case email.FieldSubject:
		m.ResetSubject()
		return nil
	case email.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case email.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Email field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Email unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Email edge %s", name)
}

// ExperienceMutation represents an operation that mutates the Experience nodes in the graph.
type ExperienceMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	company_name  *string
	start_date    *time.Time
	end_date      *time.Time
	current_place *bool
	position      *string
	created_at    *time.Time
	updated_at    *time.Time
	description   *string
	clearedFields map[string]struct{}
	user          *uint
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Experience, error)
	predicates    []predicate.Experience
}

var _ ent.Mutation = (*ExperienceMutation)(nil)

// experienceOption allows management of the mutation configuration using functional options.
type experienceOption func(*ExperienceMutation)

// newExperienceMutation creates new mutation for the Experience entity.
func newExperienceMutation(c config, op Op, opts ...experienceOption) *ExperienceMutation {
	m := &ExperienceMutation{
		config:        c,
		op:            op,
		typ:           TypeExperience,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExperienceID sets the ID field of the mutation.
func withExperienceID(id uint) experienceOption {
	return func(m *ExperienceMutation) {
		var (
			err   error
			once  sync.Once
			value *Experience
		)
		m.oldValue = func(ctx context.Context) (*Experience, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Experience.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExperience sets the old Experience of the mutation.
func withExperience(node *Experience) experienceOption {
	return func(m *ExperienceMutation) {
		m.oldValue = func(context.Context) (*Experience, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExperienceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExperienceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Experience entities.
func (m *ExperienceMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ExperienceMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ExperienceMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Experience.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyName sets the "company_name" field.
func (m *ExperienceMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *ExperienceMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *ExperienceMutation) ResetCompanyName() {
	m.company_name = nil
}

// SetStartDate sets the "start_date" field.
func (m *ExperienceMutation) SetStartDate(t time.Time) {
	m.start_date = &t
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ExperienceMutation) StartDate() (r time.Time, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ExperienceMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ExperienceMutation) SetEndDate(t time.Time) {
	m.end_date = &t
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ExperienceMutation) EndDate() (r time.Time, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldEndDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ClearEndDate clears the value of the "end_date" field.
func (m *ExperienceMutation) ClearEndDate() {
	m.end_date = nil
	m.clearedFields[experience.FieldEndDate] = struct{}{}
}

// EndDateCleared returns if the "end_date" field was cleared in this mutation.
func (m *ExperienceMutation) EndDateCleared() bool {
	_, ok := m.clearedFields[experience.FieldEndDate]
	return ok
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ExperienceMutation) ResetEndDate() {
	m.end_date = nil
	delete(m.clearedFields, experience.FieldEndDate)
}

// SetCurrentPlace sets the "current_place" field.
func (m *ExperienceMutation) SetCurrentPlace(b bool) {
	m.current_place = &b
}

// CurrentPlace returns the value of the "current_place" field in the mutation.
func (m *ExperienceMutation) CurrentPlace() (r bool, exists bool) {
	v := m.current_place
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentPlace returns the old "current_place" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldCurrentPlace(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentPlace is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentPlace requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentPlace: %w", err)
	}
	return oldValue.CurrentPlace, nil
}

// ClearCurrentPlace clears the value of the "current_place" field.
func (m *ExperienceMutation) ClearCurrentPlace() {
	m.current_place = nil
	m.clearedFields[experience.FieldCurrentPlace] = struct{}{}
}

// CurrentPlaceCleared returns if the "current_place" field was cleared in this mutation.
func (m *ExperienceMutation) CurrentPlaceCleared() bool {
	_, ok := m.clearedFields[experience.FieldCurrentPlace]
	return ok
}

// ResetCurrentPlace resets all changes to the "current_place" field.
func (m *ExperienceMutation) ResetCurrentPlace() {
	m.current_place = nil
	delete(m.clearedFields, experience.FieldCurrentPlace)
}

// SetPosition sets the "position" field.
func (m *ExperienceMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *ExperienceMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *ExperienceMutation) ResetPosition() {
	m.position = nil
}

// SetUserID sets the "user_id" field.
func (m *ExperienceMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ExperienceMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *ExperienceMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[experience.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *ExperienceMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[experience.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ExperienceMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, experience.FieldUserID)
}

// SetCreatedAt sets the "created_at" field.
func (m *ExperienceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ExperienceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ExperienceMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[experience.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ExperienceMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[experience.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ExperienceMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, experience.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ExperienceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ExperienceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *ExperienceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[experience.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *ExperienceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[experience.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ExperienceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, experience.FieldUpdatedAt)
}

// SetDescription sets the "description" field.
func (m *ExperienceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ExperienceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Experience entity.
// If the Experience object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ExperienceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ExperienceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[experience.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ExperienceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[experience.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ExperienceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, experience.FieldDescription)
}

// ClearUser clears the "user" edge to the User entity.
func (m *ExperienceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[experience.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ExperienceMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ExperienceMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ExperienceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ExperienceMutation builder.
func (m *ExperienceMutation) Where(ps ...predicate.Experience) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ExperienceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ExperienceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Experience, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ExperienceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ExperienceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Experience).
func (m *ExperienceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ExperienceMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.company_name != nil {
		fields = append(fields, experience.FieldCompanyName)
	}
	if m.start_date != nil {
		fields = append(fields, experience.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, experience.FieldEndDate)
	}
	if m.current_place != nil {
		fields = append(fields, experience.FieldCurrentPlace)
	}
	if m.position != nil {
		fields = append(fields, experience.FieldPosition)
	}
	if m.user != nil {
		fields = append(fields, experience.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, experience.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, experience.FieldUpdatedAt)
	}
	if m.description != nil {
		fields = append(fields, experience.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ExperienceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case experience.FieldCompanyName:
		return m.CompanyName()
	case experience.FieldStartDate:
		return m.StartDate()
	case experience.FieldEndDate:
		return m.EndDate()
	case experience.FieldCurrentPlace:
		return m.CurrentPlace()
	case experience.FieldPosition:
		return m.Position()
	case experience.FieldUserID:
		return m.UserID()
	case experience.FieldCreatedAt:
		return m.CreatedAt()
	case experience.FieldUpdatedAt:
		return m.UpdatedAt()
	case experience.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ExperienceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case experience.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case experience.FieldStartDate:
		return m.OldStartDate(ctx)
	case experience.FieldEndDate:
		return m.OldEndDate(ctx)
	case experience.FieldCurrentPlace:
		return m.OldCurrentPlace(ctx)
	case experience.FieldPosition:
		return m.OldPosition(ctx)
	case experience.FieldUserID:
		return m.OldUserID(ctx)
	case experience.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case experience.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case experience.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Experience field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case experience.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case experience.FieldStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case experience.FieldEndDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case experience.FieldCurrentPlace:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentPlace(v)
		return nil
	case experience.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case experience.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case experience.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case experience.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case experience.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Experience field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ExperienceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ExperienceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ExperienceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Experience numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ExperienceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(experience.FieldEndDate) {
		fields = append(fields, experience.FieldEndDate)
	}
	if m.FieldCleared(experience.FieldCurrentPlace) {
		fields = append(fields, experience.FieldCurrentPlace)
	}
	if m.FieldCleared(experience.FieldUserID) {
		fields = append(fields, experience.FieldUserID)
	}
	if m.FieldCleared(experience.FieldCreatedAt) {
		fields = append(fields, experience.FieldCreatedAt)
	}
	if m.FieldCleared(experience.FieldUpdatedAt) {
		fields = append(fields, experience.FieldUpdatedAt)
	}
	if m.FieldCleared(experience.FieldDescription) {
		fields = append(fields, experience.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ExperienceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExperienceMutation) ClearField(name string) error {
	switch name {
	case experience.FieldEndDate:
		m.ClearEndDate()
		return nil
	case experience.FieldCurrentPlace:
		m.ClearCurrentPlace()
		return nil
	case experience.FieldUserID:
		m.ClearUserID()
		return nil
	case experience.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case experience.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case experience.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Experience nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ExperienceMutation) ResetField(name string) error {
	switch name {
	case experience.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case experience.FieldStartDate:
		m.ResetStartDate()
		return nil
	case experience.FieldEndDate:
		m.ResetEndDate()
		return nil
	case experience.FieldCurrentPlace:
		m.ResetCurrentPlace()
		return nil
	case experience.FieldPosition:
		m.ResetPosition()
		return nil
	case experience.FieldUserID:
		m.ResetUserID()
		return nil
	case experience.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case experience.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case experience.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Experience field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ExperienceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, experience.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ExperienceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case experience.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ExperienceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ExperienceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ExperienceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, experience.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ExperienceMutation) EdgeCleared(name string) bool {
	switch name {
	case experience.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ExperienceMutation) ClearEdge(name string) error {
	switch name {
	case experience.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Experience unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ExperienceMutation) ResetEdge(name string) error {
	switch name {
	case experience.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Experience edge %s", name)
}

// RepositoryMutation represents an operation that mutates the Repository nodes in the graph.
type RepositoryMutation struct {
	config
	op               Op
	typ              string
	id               *uint
	repo_name        *string
	repo_description *string
	repo_url         *string
	repo_language    *string
	repo_created_at  *time.Time
	repo_updated_at  *time.Time
	created_at       *time.Time
	updated_at       *time.Time
	show_on_profile  *bool
	_order           *int32
	add_order        *int32
	clearedFields    map[string]struct{}
	user             *uint
	cleareduser      bool
	done             bool
	oldValue         func(context.Context) (*Repository, error)
	predicates       []predicate.Repository
}

var _ ent.Mutation = (*RepositoryMutation)(nil)

// repositoryOption allows management of the mutation configuration using functional options.
type repositoryOption func(*RepositoryMutation)

// newRepositoryMutation creates new mutation for the Repository entity.
func newRepositoryMutation(c config, op Op, opts ...repositoryOption) *RepositoryMutation {
	m := &RepositoryMutation{
		config:        c,
		op:            op,
		typ:           TypeRepository,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRepositoryID sets the ID field of the mutation.
func withRepositoryID(id uint) repositoryOption {
	return func(m *RepositoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Repository
		)
		m.oldValue = func(ctx context.Context) (*Repository, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Repository.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRepository sets the old Repository of the mutation.
func withRepository(node *Repository) repositoryOption {
	return func(m *RepositoryMutation) {
		m.oldValue = func(context.Context) (*Repository, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RepositoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RepositoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Repository entities.
func (m *RepositoryMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RepositoryMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RepositoryMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Repository.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRepoName sets the "repo_name" field.
func (m *RepositoryMutation) SetRepoName(s string) {
	m.repo_name = &s
}

// RepoName returns the value of the "repo_name" field in the mutation.
func (m *RepositoryMutation) RepoName() (r string, exists bool) {
	v := m.repo_name
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoName returns the old "repo_name" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoName: %w", err)
	}
	return oldValue.RepoName, nil
}

// ResetRepoName resets all changes to the "repo_name" field.
func (m *RepositoryMutation) ResetRepoName() {
	m.repo_name = nil
}

// SetRepoDescription sets the "repo_description" field.
func (m *RepositoryMutation) SetRepoDescription(s string) {
	m.repo_description = &s
}

// RepoDescription returns the value of the "repo_description" field in the mutation.
func (m *RepositoryMutation) RepoDescription() (r string, exists bool) {
	v := m.repo_description
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoDescription returns the old "repo_description" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoDescription: %w", err)
	}
	return oldValue.RepoDescription, nil
}

// ClearRepoDescription clears the value of the "repo_description" field.
func (m *RepositoryMutation) ClearRepoDescription() {
	m.repo_description = nil
	m.clearedFields[repository.FieldRepoDescription] = struct{}{}
}

// RepoDescriptionCleared returns if the "repo_description" field was cleared in this mutation.
func (m *RepositoryMutation) RepoDescriptionCleared() bool {
	_, ok := m.clearedFields[repository.FieldRepoDescription]
	return ok
}

// ResetRepoDescription resets all changes to the "repo_description" field.
func (m *RepositoryMutation) ResetRepoDescription() {
	m.repo_description = nil
	delete(m.clearedFields, repository.FieldRepoDescription)
}

// SetRepoURL sets the "repo_url" field.
func (m *RepositoryMutation) SetRepoURL(s string) {
	m.repo_url = &s
}

// RepoURL returns the value of the "repo_url" field in the mutation.
func (m *RepositoryMutation) RepoURL() (r string, exists bool) {
	v := m.repo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoURL returns the old "repo_url" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoURL: %w", err)
	}
	return oldValue.RepoURL, nil
}

// ResetRepoURL resets all changes to the "repo_url" field.
func (m *RepositoryMutation) ResetRepoURL() {
	m.repo_url = nil
}

// SetRepoLanguage sets the "repo_language" field.
func (m *RepositoryMutation) SetRepoLanguage(s string) {
	m.repo_language = &s
}

// RepoLanguage returns the value of the "repo_language" field in the mutation.
func (m *RepositoryMutation) RepoLanguage() (r string, exists bool) {
	v := m.repo_language
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoLanguage returns the old "repo_language" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoLanguage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoLanguage: %w", err)
	}
	return oldValue.RepoLanguage, nil
}

// ClearRepoLanguage clears the value of the "repo_language" field.
func (m *RepositoryMutation) ClearRepoLanguage() {
	m.repo_language = nil
	m.clearedFields[repository.FieldRepoLanguage] = struct{}{}
}

// RepoLanguageCleared returns if the "repo_language" field was cleared in this mutation.
func (m *RepositoryMutation) RepoLanguageCleared() bool {
	_, ok := m.clearedFields[repository.FieldRepoLanguage]
	return ok
}

// ResetRepoLanguage resets all changes to the "repo_language" field.
func (m *RepositoryMutation) ResetRepoLanguage() {
	m.repo_language = nil
	delete(m.clearedFields, repository.FieldRepoLanguage)
}

// SetRepoCreatedAt sets the "repo_created_at" field.
func (m *RepositoryMutation) SetRepoCreatedAt(t time.Time) {
	m.repo_created_at = &t
}

// RepoCreatedAt returns the value of the "repo_created_at" field in the mutation.
func (m *RepositoryMutation) RepoCreatedAt() (r time.Time, exists bool) {
	v := m.repo_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoCreatedAt returns the old "repo_created_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoCreatedAt: %w", err)
	}
	return oldValue.RepoCreatedAt, nil
}

// ResetRepoCreatedAt resets all changes to the "repo_created_at" field.
func (m *RepositoryMutation) ResetRepoCreatedAt() {
	m.repo_created_at = nil
}

// SetRepoUpdatedAt sets the "repo_updated_at" field.
func (m *RepositoryMutation) SetRepoUpdatedAt(t time.Time) {
	m.repo_updated_at = &t
}

// RepoUpdatedAt returns the value of the "repo_updated_at" field in the mutation.
func (m *RepositoryMutation) RepoUpdatedAt() (r time.Time, exists bool) {
	v := m.repo_updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRepoUpdatedAt returns the old "repo_updated_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldRepoUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRepoUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRepoUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRepoUpdatedAt: %w", err)
	}
	return oldValue.RepoUpdatedAt, nil
}

// ResetRepoUpdatedAt resets all changes to the "repo_updated_at" field.
func (m *RepositoryMutation) ResetRepoUpdatedAt() {
	m.repo_updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *RepositoryMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *RepositoryMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *RepositoryMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[repository.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *RepositoryMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[repository.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *RepositoryMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, repository.FieldUserID)
}

// SetCreatedAt sets the "created_at" field.
func (m *RepositoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RepositoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *RepositoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[repository.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *RepositoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[repository.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RepositoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, repository.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *RepositoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *RepositoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *RepositoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[repository.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *RepositoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[repository.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *RepositoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, repository.FieldUpdatedAt)
}

// SetShowOnProfile sets the "show_on_profile" field.
func (m *RepositoryMutation) SetShowOnProfile(b bool) {
	m.show_on_profile = &b
}

// ShowOnProfile returns the value of the "show_on_profile" field in the mutation.
func (m *RepositoryMutation) ShowOnProfile() (r bool, exists bool) {
	v := m.show_on_profile
	if v == nil {
		return
	}
	return *v, true
}

// OldShowOnProfile returns the old "show_on_profile" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldShowOnProfile(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShowOnProfile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShowOnProfile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShowOnProfile: %w", err)
	}
	return oldValue.ShowOnProfile, nil
}

// ResetShowOnProfile resets all changes to the "show_on_profile" field.
func (m *RepositoryMutation) ResetShowOnProfile() {
	m.show_on_profile = nil
}

// SetOrder sets the "order" field.
func (m *RepositoryMutation) SetOrder(i int32) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *RepositoryMutation) Order() (r int32, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Repository entity.
// If the Repository object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RepositoryMutation) OldOrder(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *RepositoryMutation) AddOrder(i int32) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *RepositoryMutation) AddedOrder() (r int32, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *RepositoryMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *RepositoryMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[repository.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *RepositoryMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *RepositoryMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *RepositoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the RepositoryMutation builder.
func (m *RepositoryMutation) Where(ps ...predicate.Repository) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RepositoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RepositoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Repository, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RepositoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RepositoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Repository).
func (m *RepositoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RepositoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.repo_name != nil {
		fields = append(fields, repository.FieldRepoName)
	}
	if m.repo_description != nil {
		fields = append(fields, repository.FieldRepoDescription)
	}
	if m.repo_url != nil {
		fields = append(fields, repository.FieldRepoURL)
	}
	if m.repo_language != nil {
		fields = append(fields, repository.FieldRepoLanguage)
	}
	if m.repo_created_at != nil {
		fields = append(fields, repository.FieldRepoCreatedAt)
	}
	if m.repo_updated_at != nil {
		fields = append(fields, repository.FieldRepoUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, repository.FieldUserID)
	}
	if m.created_at != nil {
		fields = append(fields, repository.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, repository.FieldUpdatedAt)
	}
	if m.show_on_profile != nil {
		fields = append(fields, repository.FieldShowOnProfile)
	}
	if m._order != nil {
		fields = append(fields, repository.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RepositoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldRepoName:
		return m.RepoName()
	case repository.FieldRepoDescription:
		return m.RepoDescription()
	case repository.FieldRepoURL:
		return m.RepoURL()
	case repository.FieldRepoLanguage:
		return m.RepoLanguage()
	case repository.FieldRepoCreatedAt:
		return m.RepoCreatedAt()
	case repository.FieldRepoUpdatedAt:
		return m.RepoUpdatedAt()
	case repository.FieldUserID:
		return m.UserID()
	case repository.FieldCreatedAt:
		return m.CreatedAt()
	case repository.FieldUpdatedAt:
		return m.UpdatedAt()
	case repository.FieldShowOnProfile:
		return m.ShowOnProfile()
	case repository.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RepositoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case repository.FieldRepoName:
		return m.OldRepoName(ctx)
	case repository.FieldRepoDescription:
		return m.OldRepoDescription(ctx)
	case repository.FieldRepoURL:
		return m.OldRepoURL(ctx)
	case repository.FieldRepoLanguage:
		return m.OldRepoLanguage(ctx)
	case repository.FieldRepoCreatedAt:
		return m.OldRepoCreatedAt(ctx)
	case repository.FieldRepoUpdatedAt:
		return m.OldRepoUpdatedAt(ctx)
	case repository.FieldUserID:
		return m.OldUserID(ctx)
	case repository.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case repository.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case repository.FieldShowOnProfile:
		return m.OldShowOnProfile(ctx)
	case repository.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Repository field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case repository.FieldRepoName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoName(v)
		return nil
	case repository.FieldRepoDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoDescription(v)
		return nil
	case repository.FieldRepoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoURL(v)
		return nil
	case repository.FieldRepoLanguage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoLanguage(v)
		return nil
	case repository.FieldRepoCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoCreatedAt(v)
		return nil
	case repository.FieldRepoUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRepoUpdatedAt(v)
		return nil
	case repository.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case repository.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case repository.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case repository.FieldShowOnProfile:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShowOnProfile(v)
		return nil
	case repository.FieldOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RepositoryMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, repository.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RepositoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case repository.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RepositoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case repository.FieldOrder:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Repository numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RepositoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(repository.FieldRepoDescription) {
		fields = append(fields, repository.FieldRepoDescription)
	}
	if m.FieldCleared(repository.FieldRepoLanguage) {
		fields = append(fields, repository.FieldRepoLanguage)
	}
	if m.FieldCleared(repository.FieldUserID) {
		fields = append(fields, repository.FieldUserID)
	}
	if m.FieldCleared(repository.FieldCreatedAt) {
		fields = append(fields, repository.FieldCreatedAt)
	}
	if m.FieldCleared(repository.FieldUpdatedAt) {
		fields = append(fields, repository.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RepositoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RepositoryMutation) ClearField(name string) error {
	switch name {
	case repository.FieldRepoDescription:
		m.ClearRepoDescription()
		return nil
	case repository.FieldRepoLanguage:
		m.ClearRepoLanguage()
		return nil
	case repository.FieldUserID:
		m.ClearUserID()
		return nil
	case repository.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case repository.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Repository nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RepositoryMutation) ResetField(name string) error {
	switch name {
	case repository.FieldRepoName:
		m.ResetRepoName()
		return nil
	case repository.FieldRepoDescription:
		m.ResetRepoDescription()
		return nil
	case repository.FieldRepoURL:
		m.ResetRepoURL()
		return nil
	case repository.FieldRepoLanguage:
		m.ResetRepoLanguage()
		return nil
	case repository.FieldRepoCreatedAt:
		m.ResetRepoCreatedAt()
		return nil
	case repository.FieldRepoUpdatedAt:
		m.ResetRepoUpdatedAt()
		return nil
	case repository.FieldUserID:
		m.ResetUserID()
		return nil
	case repository.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case repository.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case repository.FieldShowOnProfile:
		m.ResetShowOnProfile()
		return nil
	case repository.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Repository field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RepositoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, repository.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RepositoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case repository.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RepositoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RepositoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RepositoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, repository.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RepositoryMutation) EdgeCleared(name string) bool {
	switch name {
	case repository.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RepositoryMutation) ClearEdge(name string) error {
	switch name {
	case repository.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Repository unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RepositoryMutation) ResetEdge(name string) error {
	switch name {
	case repository.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Repository edge %s", name)
}

// SkillMutation represents an operation that mutates the Skill nodes in the graph.
type SkillMutation struct {
	config
	op                            Op
	typ                           string
	id                            *uint
	name                          *string
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	user_skill_association        *uint
	cleareduser_skill_association bool
	done                          bool
	oldValue                      func(context.Context) (*Skill, error)
	predicates                    []predicate.Skill
}

var _ ent.Mutation = (*SkillMutation)(nil)

// skillOption allows management of the mutation configuration using functional options.
type skillOption func(*SkillMutation)

// newSkillMutation creates new mutation for the Skill entity.
func newSkillMutation(c config, op Op, opts ...skillOption) *SkillMutation {
	m := &SkillMutation{
		config:        c,
		op:            op,
		typ:           TypeSkill,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSkillID sets the ID field of the mutation.
func withSkillID(id uint) skillOption {
	return func(m *SkillMutation) {
		var (
			err   error
			once  sync.Once
			value *Skill
		)
		m.oldValue = func(ctx context.Context) (*Skill, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Skill.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSkill sets the old Skill of the mutation.
func withSkill(node *Skill) skillOption {
	return func(m *SkillMutation) {
		m.oldValue = func(context.Context) (*Skill, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SkillMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SkillMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Skill entities.
func (m *SkillMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SkillMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SkillMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Skill.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SkillMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SkillMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SkillMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SkillMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SkillMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SkillMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[skill.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SkillMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[skill.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SkillMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, skill.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SkillMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SkillMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Skill entity.
// If the Skill object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SkillMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SkillMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[skill.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SkillMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[skill.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SkillMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, skill.FieldUpdatedAt)
}

// SetUserSkillAssociationID sets the "user_skill_association" edge to the UserSkillAssociation entity by id.
func (m *SkillMutation) SetUserSkillAssociationID(id uint) {
	m.user_skill_association = &id
}

// ClearUserSkillAssociation clears the "user_skill_association" edge to the UserSkillAssociation entity.
func (m *SkillMutation) ClearUserSkillAssociation() {
	m.cleareduser_skill_association = true
}

// UserSkillAssociationCleared reports if the "user_skill_association" edge to the UserSkillAssociation entity was cleared.
func (m *SkillMutation) UserSkillAssociationCleared() bool {
	return m.cleareduser_skill_association
}

// UserSkillAssociationID returns the "user_skill_association" edge ID in the mutation.
func (m *SkillMutation) UserSkillAssociationID() (id uint, exists bool) {
	if m.user_skill_association != nil {
		return *m.user_skill_association, true
	}
	return
}

// UserSkillAssociationIDs returns the "user_skill_association" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserSkillAssociationID instead. It exists only for internal usage by the builders.
func (m *SkillMutation) UserSkillAssociationIDs() (ids []uint) {
	if id := m.user_skill_association; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUserSkillAssociation resets all changes to the "user_skill_association" edge.
func (m *SkillMutation) ResetUserSkillAssociation() {
	m.user_skill_association = nil
	m.cleareduser_skill_association = false
}

// Where appends a list predicates to the SkillMutation builder.
func (m *SkillMutation) Where(ps ...predicate.Skill) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SkillMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SkillMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Skill, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SkillMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SkillMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Skill).
func (m *SkillMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SkillMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, skill.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, skill.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, skill.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SkillMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case skill.FieldName:
		return m.Name()
	case skill.FieldCreatedAt:
		return m.CreatedAt()
	case skill.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SkillMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case skill.FieldName:
		return m.OldName(ctx)
	case skill.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case skill.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Skill field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) SetField(name string, value ent.Value) error {
	switch name {
	case skill.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case skill.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case skill.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SkillMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SkillMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SkillMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Skill numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SkillMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(skill.FieldCreatedAt) {
		fields = append(fields, skill.FieldCreatedAt)
	}
	if m.FieldCleared(skill.FieldUpdatedAt) {
		fields = append(fields, skill.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SkillMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SkillMutation) ClearField(name string) error {
	switch name {
	case skill.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case skill.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Skill nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SkillMutation) ResetField(name string) error {
	switch name {
	case skill.FieldName:
		m.ResetName()
		return nil
	case skill.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case skill.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Skill field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SkillMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_skill_association != nil {
		edges = append(edges, skill.EdgeUserSkillAssociation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SkillMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case skill.EdgeUserSkillAssociation:
		if id := m.user_skill_association; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SkillMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SkillMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SkillMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser_skill_association {
		edges = append(edges, skill.EdgeUserSkillAssociation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SkillMutation) EdgeCleared(name string) bool {
	switch name {
	case skill.EdgeUserSkillAssociation:
		return m.cleareduser_skill_association
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SkillMutation) ClearEdge(name string) error {
	switch name {
	case skill.EdgeUserSkillAssociation:
		m.ClearUserSkillAssociation()
		return nil
	}
	return fmt.Errorf("unknown Skill unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SkillMutation) ResetEdge(name string) error {
	switch name {
	case skill.EdgeUserSkillAssociation:
		m.ResetUserSkillAssociation()
		return nil
	}
	return fmt.Errorf("unknown Skill edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                             Op
	typ                            string
	id                             *uint
	first_name                     *string
	last_name                      *string
	dob                            *time.Time
	username                       *string
	password                       *string
	email                          *string
	github_username                *string
	description                    *string
	created_at                     *time.Time
	updated_at                     *time.Time
	mobile_number                  *int32
	addmobile_number               *int32
	address_block                  *string
	address_street                 *string
	recidential_country            *string
	nationality                    *string
	clearedFields                  map[string]struct{}
	educations                     map[uint]struct{}
	removededucations              map[uint]struct{}
	clearededucations              bool
	experiences                    map[uint]struct{}
	removedexperiences             map[uint]struct{}
	clearedexperiences             bool
	repositories                   map[uint]struct{}
	removedrepositories            map[uint]struct{}
	clearedrepositories            bool
	user_projects                  map[uint]struct{}
	removeduser_projects           map[uint]struct{}
	cleareduser_projects           bool
	user_services                  map[uint]struct{}
	removeduser_services           map[uint]struct{}
	cleareduser_services           bool
	user_skill_associations        map[uint]struct{}
	removeduser_skill_associations map[uint]struct{}
	cleareduser_skill_associations bool
	done                           bool
	oldValue                       func(context.Context) (*User, error)
	predicates                     []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uint) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetDob sets the "dob" field.
func (m *UserMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *UserMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ClearDob clears the value of the "dob" field.
func (m *UserMutation) ClearDob() {
	m.dob = nil
	m.clearedFields[user.FieldDob] = struct{}{}
}

// DobCleared returns if the "dob" field was cleared in this mutation.
func (m *UserMutation) DobCleared() bool {
	_, ok := m.clearedFields[user.FieldDob]
	return ok
}

// ResetDob resets all changes to the "dob" field.
func (m *UserMutation) ResetDob() {
	m.dob = nil
	delete(m.clearedFields, user.FieldDob)
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetGithubUsername sets the "github_username" field.
func (m *UserMutation) SetGithubUsername(s string) {
	m.github_username = &s
}

// GithubUsername returns the value of the "github_username" field in the mutation.
func (m *UserMutation) GithubUsername() (r string, exists bool) {
	v := m.github_username
	if v == nil {
		return
	}
	return *v, true
}

// OldGithubUsername returns the old "github_username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGithubUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGithubUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGithubUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGithubUsername: %w", err)
	}
	return oldValue.GithubUsername, nil
}

// ClearGithubUsername clears the value of the "github_username" field.
func (m *UserMutation) ClearGithubUsername() {
	m.github_username = nil
	m.clearedFields[user.FieldGithubUsername] = struct{}{}
}

// GithubUsernameCleared returns if the "github_username" field was cleared in this mutation.
func (m *UserMutation) GithubUsernameCleared() bool {
	_, ok := m.clearedFields[user.FieldGithubUsername]
	return ok
}

// ResetGithubUsername resets all changes to the "github_username" field.
func (m *UserMutation) ResetGithubUsername() {
	m.github_username = nil
	delete(m.clearedFields, user.FieldGithubUsername)
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[user.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[user.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, user.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetMobileNumber sets the "mobile_number" field.
func (m *UserMutation) SetMobileNumber(i int32) {
	m.mobile_number = &i
	m.addmobile_number = nil
}

// MobileNumber returns the value of the "mobile_number" field in the mutation.
func (m *UserMutation) MobileNumber() (r int32, exists bool) {
	v := m.mobile_number
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileNumber returns the old "mobile_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobileNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileNumber: %w", err)
	}
	return oldValue.MobileNumber, nil
}

// AddMobileNumber adds i to the "mobile_number" field.
func (m *UserMutation) AddMobileNumber(i int32) {
	if m.addmobile_number != nil {
		*m.addmobile_number += i
	} else {
		m.addmobile_number = &i
	}
}

// AddedMobileNumber returns the value that was added to the "mobile_number" field in this mutation.
func (m *UserMutation) AddedMobileNumber() (r int32, exists bool) {
	v := m.addmobile_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearMobileNumber clears the value of the "mobile_number" field.
func (m *UserMutation) ClearMobileNumber() {
	m.mobile_number = nil
	m.addmobile_number = nil
	m.clearedFields[user.FieldMobileNumber] = struct{}{}
}

// MobileNumberCleared returns if the "mobile_number" field was cleared in this mutation.
func (m *UserMutation) MobileNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldMobileNumber]
	return ok
}

// ResetMobileNumber resets all changes to the "mobile_number" field.
func (m *UserMutation) ResetMobileNumber() {
	m.mobile_number = nil
	m.addmobile_number = nil
	delete(m.clearedFields, user.FieldMobileNumber)
}

// SetAddressBlock sets the "address_block" field.
func (m *UserMutation) SetAddressBlock(s string) {
	m.address_block = &s
}

// AddressBlock returns the value of the "address_block" field in the mutation.
func (m *UserMutation) AddressBlock() (r string, exists bool) {
	v := m.address_block
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressBlock returns the old "address_block" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddressBlock(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressBlock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressBlock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressBlock: %w", err)
	}
	return oldValue.AddressBlock, nil
}

// ClearAddressBlock clears the value of the "address_block" field.
func (m *UserMutation) ClearAddressBlock() {
	m.address_block = nil
	m.clearedFields[user.FieldAddressBlock] = struct{}{}
}

// AddressBlockCleared returns if the "address_block" field was cleared in this mutation.
func (m *UserMutation) AddressBlockCleared() bool {
	_, ok := m.clearedFields[user.FieldAddressBlock]
	return ok
}

// ResetAddressBlock resets all changes to the "address_block" field.
func (m *UserMutation) ResetAddressBlock() {
	m.address_block = nil
	delete(m.clearedFields, user.FieldAddressBlock)
}

// SetAddressStreet sets the "address_street" field.
func (m *UserMutation) SetAddressStreet(s string) {
	m.address_street = &s
}

// AddressStreet returns the value of the "address_street" field in the mutation.
func (m *UserMutation) AddressStreet() (r string, exists bool) {
	v := m.address_street
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressStreet returns the old "address_street" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddressStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressStreet: %w", err)
	}
	return oldValue.AddressStreet, nil
}

// ClearAddressStreet clears the value of the "address_street" field.
func (m *UserMutation) ClearAddressStreet() {
	m.address_street = nil
	m.clearedFields[user.FieldAddressStreet] = struct{}{}
}

// AddressStreetCleared returns if the "address_street" field was cleared in this mutation.
func (m *UserMutation) AddressStreetCleared() bool {
	_, ok := m.clearedFields[user.FieldAddressStreet]
	return ok
}

// ResetAddressStreet resets all changes to the "address_street" field.
func (m *UserMutation) ResetAddressStreet() {
	m.address_street = nil
	delete(m.clearedFields, user.FieldAddressStreet)
}

// SetRecidentialCountry sets the "recidential_country" field.
func (m *UserMutation) SetRecidentialCountry(s string) {
	m.recidential_country = &s
}

// RecidentialCountry returns the value of the "recidential_country" field in the mutation.
func (m *UserMutation) RecidentialCountry() (r string, exists bool) {
	v := m.recidential_country
	if v == nil {
		return
	}
	return *v, true
}

// OldRecidentialCountry returns the old "recidential_country" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRecidentialCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRecidentialCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRecidentialCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRecidentialCountry: %w", err)
	}
	return oldValue.RecidentialCountry, nil
}

// ClearRecidentialCountry clears the value of the "recidential_country" field.
func (m *UserMutation) ClearRecidentialCountry() {
	m.recidential_country = nil
	m.clearedFields[user.FieldRecidentialCountry] = struct{}{}
}

// RecidentialCountryCleared returns if the "recidential_country" field was cleared in this mutation.
func (m *UserMutation) RecidentialCountryCleared() bool {
	_, ok := m.clearedFields[user.FieldRecidentialCountry]
	return ok
}

// ResetRecidentialCountry resets all changes to the "recidential_country" field.
func (m *UserMutation) ResetRecidentialCountry() {
	m.recidential_country = nil
	delete(m.clearedFields, user.FieldRecidentialCountry)
}

// SetNationality sets the "nationality" field.
func (m *UserMutation) SetNationality(s string) {
	m.nationality = &s
}

// Nationality returns the value of the "nationality" field in the mutation.
func (m *UserMutation) Nationality() (r string, exists bool) {
	v := m.nationality
	if v == nil {
		return
	}
	return *v, true
}

// OldNationality returns the old "nationality" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNationality(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNationality is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNationality requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNationality: %w", err)
	}
	return oldValue.Nationality, nil
}

// ClearNationality clears the value of the "nationality" field.
func (m *UserMutation) ClearNationality() {
	m.nationality = nil
	m.clearedFields[user.FieldNationality] = struct{}{}
}

// NationalityCleared returns if the "nationality" field was cleared in this mutation.
func (m *UserMutation) NationalityCleared() bool {
	_, ok := m.clearedFields[user.FieldNationality]
	return ok
}

// ResetNationality resets all changes to the "nationality" field.
func (m *UserMutation) ResetNationality() {
	m.nationality = nil
	delete(m.clearedFields, user.FieldNationality)
}

// AddEducationIDs adds the "educations" edge to the Education entity by ids.
func (m *UserMutation) AddEducationIDs(ids ...uint) {
	if m.educations == nil {
		m.educations = make(map[uint]struct{})
	}
	for i := range ids {
		m.educations[ids[i]] = struct{}{}
	}
}

// ClearEducations clears the "educations" edge to the Education entity.
func (m *UserMutation) ClearEducations() {
	m.clearededucations = true
}

// EducationsCleared reports if the "educations" edge to the Education entity was cleared.
func (m *UserMutation) EducationsCleared() bool {
	return m.clearededucations
}

// RemoveEducationIDs removes the "educations" edge to the Education entity by IDs.
func (m *UserMutation) RemoveEducationIDs(ids ...uint) {
	if m.removededucations == nil {
		m.removededucations = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.educations, ids[i])
		m.removededucations[ids[i]] = struct{}{}
	}
}

// RemovedEducations returns the removed IDs of the "educations" edge to the Education entity.
func (m *UserMutation) RemovedEducationsIDs() (ids []uint) {
	for id := range m.removededucations {
		ids = append(ids, id)
	}
	return
}

// EducationsIDs returns the "educations" edge IDs in the mutation.
func (m *UserMutation) EducationsIDs() (ids []uint) {
	for id := range m.educations {
		ids = append(ids, id)
	}
	return
}

// ResetEducations resets all changes to the "educations" edge.
func (m *UserMutation) ResetEducations() {
	m.educations = nil
	m.clearededucations = false
	m.removededucations = nil
}

// AddExperienceIDs adds the "experiences" edge to the Experience entity by ids.
func (m *UserMutation) AddExperienceIDs(ids ...uint) {
	if m.experiences == nil {
		m.experiences = make(map[uint]struct{})
	}
	for i := range ids {
		m.experiences[ids[i]] = struct{}{}
	}
}

// ClearExperiences clears the "experiences" edge to the Experience entity.
func (m *UserMutation) ClearExperiences() {
	m.clearedexperiences = true
}

// ExperiencesCleared reports if the "experiences" edge to the Experience entity was cleared.
func (m *UserMutation) ExperiencesCleared() bool {
	return m.clearedexperiences
}

// RemoveExperienceIDs removes the "experiences" edge to the Experience entity by IDs.
func (m *UserMutation) RemoveExperienceIDs(ids ...uint) {
	if m.removedexperiences == nil {
		m.removedexperiences = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.experiences, ids[i])
		m.removedexperiences[ids[i]] = struct{}{}
	}
}

// RemovedExperiences returns the removed IDs of the "experiences" edge to the Experience entity.
func (m *UserMutation) RemovedExperiencesIDs() (ids []uint) {
	for id := range m.removedexperiences {
		ids = append(ids, id)
	}
	return
}

// ExperiencesIDs returns the "experiences" edge IDs in the mutation.
func (m *UserMutation) ExperiencesIDs() (ids []uint) {
	for id := range m.experiences {
		ids = append(ids, id)
	}
	return
}

// ResetExperiences resets all changes to the "experiences" edge.
func (m *UserMutation) ResetExperiences() {
	m.experiences = nil
	m.clearedexperiences = false
	m.removedexperiences = nil
}

// AddRepositoryIDs adds the "repositories" edge to the Repository entity by ids.
func (m *UserMutation) AddRepositoryIDs(ids ...uint) {
	if m.repositories == nil {
		m.repositories = make(map[uint]struct{})
	}
	for i := range ids {
		m.repositories[ids[i]] = struct{}{}
	}
}

// ClearRepositories clears the "repositories" edge to the Repository entity.
func (m *UserMutation) ClearRepositories() {
	m.clearedrepositories = true
}

// RepositoriesCleared reports if the "repositories" edge to the Repository entity was cleared.
func (m *UserMutation) RepositoriesCleared() bool {
	return m.clearedrepositories
}

// RemoveRepositoryIDs removes the "repositories" edge to the Repository entity by IDs.
func (m *UserMutation) RemoveRepositoryIDs(ids ...uint) {
	if m.removedrepositories == nil {
		m.removedrepositories = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.repositories, ids[i])
		m.removedrepositories[ids[i]] = struct{}{}
	}
}

// RemovedRepositories returns the removed IDs of the "repositories" edge to the Repository entity.
func (m *UserMutation) RemovedRepositoriesIDs() (ids []uint) {
	for id := range m.removedrepositories {
		ids = append(ids, id)
	}
	return
}

// RepositoriesIDs returns the "repositories" edge IDs in the mutation.
func (m *UserMutation) RepositoriesIDs() (ids []uint) {
	for id := range m.repositories {
		ids = append(ids, id)
	}
	return
}

// ResetRepositories resets all changes to the "repositories" edge.
func (m *UserMutation) ResetRepositories() {
	m.repositories = nil
	m.clearedrepositories = false
	m.removedrepositories = nil
}

// AddUserProjectIDs adds the "user_projects" edge to the UserProject entity by ids.
func (m *UserMutation) AddUserProjectIDs(ids ...uint) {
	if m.user_projects == nil {
		m.user_projects = make(map[uint]struct{})
	}
	for i := range ids {
		m.user_projects[ids[i]] = struct{}{}
	}
}

// ClearUserProjects clears the "user_projects" edge to the UserProject entity.
func (m *UserMutation) ClearUserProjects() {
	m.cleareduser_projects = true
}

// UserProjectsCleared reports if the "user_projects" edge to the UserProject entity was cleared.
func (m *UserMutation) UserProjectsCleared() bool {
	return m.cleareduser_projects
}

// RemoveUserProjectIDs removes the "user_projects" edge to the UserProject entity by IDs.
func (m *UserMutation) RemoveUserProjectIDs(ids ...uint) {
	if m.removeduser_projects == nil {
		m.removeduser_projects = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.user_projects, ids[i])
		m.removeduser_projects[ids[i]] = struct{}{}
	}
}

// RemovedUserProjects returns the removed IDs of the "user_projects" edge to the UserProject entity.
func (m *UserMutation) RemovedUserProjectsIDs() (ids []uint) {
	for id := range m.removeduser_projects {
		ids = append(ids, id)
	}
	return
}

// UserProjectsIDs returns the "user_projects" edge IDs in the mutation.
func (m *UserMutation) UserProjectsIDs() (ids []uint) {
	for id := range m.user_projects {
		ids = append(ids, id)
	}
	return
}

// ResetUserProjects resets all changes to the "user_projects" edge.
func (m *UserMutation) ResetUserProjects() {
	m.user_projects = nil
	m.cleareduser_projects = false
	m.removeduser_projects = nil
}

// AddUserServiceIDs adds the "user_services" edge to the UserService entity by ids.
func (m *UserMutation) AddUserServiceIDs(ids ...uint) {
	if m.user_services == nil {
		m.user_services = make(map[uint]struct{})
	}
	for i := range ids {
		m.user_services[ids[i]] = struct{}{}
	}
}

// ClearUserServices clears the "user_services" edge to the UserService entity.
func (m *UserMutation) ClearUserServices() {
	m.cleareduser_services = true
}

// UserServicesCleared reports if the "user_services" edge to the UserService entity was cleared.
func (m *UserMutation) UserServicesCleared() bool {
	return m.cleareduser_services
}

// RemoveUserServiceIDs removes the "user_services" edge to the UserService entity by IDs.
func (m *UserMutation) RemoveUserServiceIDs(ids ...uint) {
	if m.removeduser_services == nil {
		m.removeduser_services = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.user_services, ids[i])
		m.removeduser_services[ids[i]] = struct{}{}
	}
}

// RemovedUserServices returns the removed IDs of the "user_services" edge to the UserService entity.
func (m *UserMutation) RemovedUserServicesIDs() (ids []uint) {
	for id := range m.removeduser_services {
		ids = append(ids, id)
	}
	return
}

// UserServicesIDs returns the "user_services" edge IDs in the mutation.
func (m *UserMutation) UserServicesIDs() (ids []uint) {
	for id := range m.user_services {
		ids = append(ids, id)
	}
	return
}

// ResetUserServices resets all changes to the "user_services" edge.
func (m *UserMutation) ResetUserServices() {
	m.user_services = nil
	m.cleareduser_services = false
	m.removeduser_services = nil
}

// AddUserSkillAssociationIDs adds the "user_skill_associations" edge to the UserSkillAssociation entity by ids.
func (m *UserMutation) AddUserSkillAssociationIDs(ids ...uint) {
	if m.user_skill_associations == nil {
		m.user_skill_associations = make(map[uint]struct{})
	}
	for i := range ids {
		m.user_skill_associations[ids[i]] = struct{}{}
	}
}

// ClearUserSkillAssociations clears the "user_skill_associations" edge to the UserSkillAssociation entity.
func (m *UserMutation) ClearUserSkillAssociations() {
	m.cleareduser_skill_associations = true
}

// UserSkillAssociationsCleared reports if the "user_skill_associations" edge to the UserSkillAssociation entity was cleared.
func (m *UserMutation) UserSkillAssociationsCleared() bool {
	return m.cleareduser_skill_associations
}

// RemoveUserSkillAssociationIDs removes the "user_skill_associations" edge to the UserSkillAssociation entity by IDs.
func (m *UserMutation) RemoveUserSkillAssociationIDs(ids ...uint) {
	if m.removeduser_skill_associations == nil {
		m.removeduser_skill_associations = make(map[uint]struct{})
	}
	for i := range ids {
		delete(m.user_skill_associations, ids[i])
		m.removeduser_skill_associations[ids[i]] = struct{}{}
	}
}

// RemovedUserSkillAssociations returns the removed IDs of the "user_skill_associations" edge to the UserSkillAssociation entity.
func (m *UserMutation) RemovedUserSkillAssociationsIDs() (ids []uint) {
	for id := range m.removeduser_skill_associations {
		ids = append(ids, id)
	}
	return
}

// UserSkillAssociationsIDs returns the "user_skill_associations" edge IDs in the mutation.
func (m *UserMutation) UserSkillAssociationsIDs() (ids []uint) {
	for id := range m.user_skill_associations {
		ids = append(ids, id)
	}
	return
}

// ResetUserSkillAssociations resets all changes to the "user_skill_associations" edge.
func (m *UserMutation) ResetUserSkillAssociations() {
	m.user_skill_associations = nil
	m.cleareduser_skill_associations = false
	m.removeduser_skill_associations = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.dob != nil {
		fields = append(fields, user.FieldDob)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.github_username != nil {
		fields = append(fields, user.FieldGithubUsername)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.mobile_number != nil {
		fields = append(fields, user.FieldMobileNumber)
	}
	if m.address_block != nil {
		fields = append(fields, user.FieldAddressBlock)
	}
	if m.address_street != nil {
		fields = append(fields, user.FieldAddressStreet)
	}
	if m.recidential_country != nil {
		fields = append(fields, user.FieldRecidentialCountry)
	}
	if m.nationality != nil {
		fields = append(fields, user.FieldNationality)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldDob:
		return m.Dob()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldGithubUsername:
		return m.GithubUsername()
	case user.FieldDescription:
		return m.Description()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldMobileNumber:
		return m.MobileNumber()
	case user.FieldAddressBlock:
		return m.AddressBlock()
	case user.FieldAddressStreet:
		return m.AddressStreet()
	case user.FieldRecidentialCountry:
		return m.RecidentialCountry()
	case user.FieldNationality:
		return m.Nationality()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldDob:
		return m.OldDob(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldGithubUsername:
		return m.OldGithubUsername(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldMobileNumber:
		return m.OldMobileNumber(ctx)
	case user.FieldAddressBlock:
		return m.OldAddressBlock(ctx)
	case user.FieldAddressStreet:
		return m.OldAddressStreet(ctx)
	case user.FieldRecidentialCountry:
		return m.OldRecidentialCountry(ctx)
	case user.FieldNationality:
		return m.OldNationality(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldGithubUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGithubUsername(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileNumber(v)
		return nil
	case user.FieldAddressBlock:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressBlock(v)
		return nil
	case user.FieldAddressStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressStreet(v)
		return nil
	case user.FieldRecidentialCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRecidentialCountry(v)
		return nil
	case user.FieldNationality:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNationality(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addmobile_number != nil {
		fields = append(fields, user.FieldMobileNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldMobileNumber:
		return m.AddedMobileNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldMobileNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMobileNumber(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldDob) {
		fields = append(fields, user.FieldDob)
	}
	if m.FieldCleared(user.FieldGithubUsername) {
		fields = append(fields, user.FieldGithubUsername)
	}
	if m.FieldCleared(user.FieldDescription) {
		fields = append(fields, user.FieldDescription)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldMobileNumber) {
		fields = append(fields, user.FieldMobileNumber)
	}
	if m.FieldCleared(user.FieldAddressBlock) {
		fields = append(fields, user.FieldAddressBlock)
	}
	if m.FieldCleared(user.FieldAddressStreet) {
		fields = append(fields, user.FieldAddressStreet)
	}
	if m.FieldCleared(user.FieldRecidentialCountry) {
		fields = append(fields, user.FieldRecidentialCountry)
	}
	if m.FieldCleared(user.FieldNationality) {
		fields = append(fields, user.FieldNationality)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldDob:
		m.ClearDob()
		return nil
	case user.FieldGithubUsername:
		m.ClearGithubUsername()
		return nil
	case user.FieldDescription:
		m.ClearDescription()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldMobileNumber:
		m.ClearMobileNumber()
		return nil
	case user.FieldAddressBlock:
		m.ClearAddressBlock()
		return nil
	case user.FieldAddressStreet:
		m.ClearAddressStreet()
		return nil
	case user.FieldRecidentialCountry:
		m.ClearRecidentialCountry()
		return nil
	case user.FieldNationality:
		m.ClearNationality()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldDob:
		m.ResetDob()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldGithubUsername:
		m.ResetGithubUsername()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldMobileNumber:
		m.ResetMobileNumber()
		return nil
	case user.FieldAddressBlock:
		m.ResetAddressBlock()
		return nil
	case user.FieldAddressStreet:
		m.ResetAddressStreet()
		return nil
	case user.FieldRecidentialCountry:
		m.ResetRecidentialCountry()
		return nil
	case user.FieldNationality:
		m.ResetNationality()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.educations != nil {
		edges = append(edges, user.EdgeEducations)
	}
	if m.experiences != nil {
		edges = append(edges, user.EdgeExperiences)
	}
	if m.repositories != nil {
		edges = append(edges, user.EdgeRepositories)
	}
	if m.user_projects != nil {
		edges = append(edges, user.EdgeUserProjects)
	}
	if m.user_services != nil {
		edges = append(edges, user.EdgeUserServices)
	}
	if m.user_skill_associations != nil {
		edges = append(edges, user.EdgeUserSkillAssociations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.educations))
		for id := range m.educations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.experiences))
		for id := range m.experiences {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.repositories))
		for id := range m.repositories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserProjects:
		ids := make([]ent.Value, 0, len(m.user_projects))
		for id := range m.user_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserServices:
		ids := make([]ent.Value, 0, len(m.user_services))
		for id := range m.user_services {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserSkillAssociations:
		ids := make([]ent.Value, 0, len(m.user_skill_associations))
		for id := range m.user_skill_associations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removededucations != nil {
		edges = append(edges, user.EdgeEducations)
	}
	if m.removedexperiences != nil {
		edges = append(edges, user.EdgeExperiences)
	}
	if m.removedrepositories != nil {
		edges = append(edges, user.EdgeRepositories)
	}
	if m.removeduser_projects != nil {
		edges = append(edges, user.EdgeUserProjects)
	}
	if m.removeduser_services != nil {
		edges = append(edges, user.EdgeUserServices)
	}
	if m.removeduser_skill_associations != nil {
		edges = append(edges, user.EdgeUserSkillAssociations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeEducations:
		ids := make([]ent.Value, 0, len(m.removededucations))
		for id := range m.removededucations {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeExperiences:
		ids := make([]ent.Value, 0, len(m.removedexperiences))
		for id := range m.removedexperiences {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeRepositories:
		ids := make([]ent.Value, 0, len(m.removedrepositories))
		for id := range m.removedrepositories {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserProjects:
		ids := make([]ent.Value, 0, len(m.removeduser_projects))
		for id := range m.removeduser_projects {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserServices:
		ids := make([]ent.Value, 0, len(m.removeduser_services))
		for id := range m.removeduser_services {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserSkillAssociations:
		ids := make([]ent.Value, 0, len(m.removeduser_skill_associations))
		for id := range m.removeduser_skill_associations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearededucations {
		edges = append(edges, user.EdgeEducations)
	}
	if m.clearedexperiences {
		edges = append(edges, user.EdgeExperiences)
	}
	if m.clearedrepositories {
		edges = append(edges, user.EdgeRepositories)
	}
	if m.cleareduser_projects {
		edges = append(edges, user.EdgeUserProjects)
	}
	if m.cleareduser_services {
		edges = append(edges, user.EdgeUserServices)
	}
	if m.cleareduser_skill_associations {
		edges = append(edges, user.EdgeUserSkillAssociations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeEducations:
		return m.clearededucations
	case user.EdgeExperiences:
		return m.clearedexperiences
	case user.EdgeRepositories:
		return m.clearedrepositories
	case user.EdgeUserProjects:
		return m.cleareduser_projects
	case user.EdgeUserServices:
		return m.cleareduser_services
	case user.EdgeUserSkillAssociations:
		return m.cleareduser_skill_associations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeEducations:
		m.ResetEducations()
		return nil
	case user.EdgeExperiences:
		m.ResetExperiences()
		return nil
	case user.EdgeRepositories:
		m.ResetRepositories()
		return nil
	case user.EdgeUserProjects:
		m.ResetUserProjects()
		return nil
	case user.EdgeUserServices:
		m.ResetUserServices()
		return nil
	case user.EdgeUserSkillAssociations:
		m.ResetUserSkillAssociations()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserProjectMutation represents an operation that mutates the UserProject nodes in the graph.
type UserProjectMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	project_name  *string
	description   *string
	from_date     *time.Time
	to_date       *time.Time
	project_link  *string
	technologies  *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *uint
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserProject, error)
	predicates    []predicate.UserProject
}

var _ ent.Mutation = (*UserProjectMutation)(nil)

// userprojectOption allows management of the mutation configuration using functional options.
type userprojectOption func(*UserProjectMutation)

// newUserProjectMutation creates new mutation for the UserProject entity.
func newUserProjectMutation(c config, op Op, opts ...userprojectOption) *UserProjectMutation {
	m := &UserProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeUserProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserProjectID sets the ID field of the mutation.
func withUserProjectID(id uint) userprojectOption {
	return func(m *UserProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *UserProject
		)
		m.oldValue = func(ctx context.Context) (*UserProject, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserProject.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserProject sets the old UserProject of the mutation.
func withUserProject(node *UserProject) userprojectOption {
	return func(m *UserProjectMutation) {
		m.oldValue = func(context.Context) (*UserProject, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserProject entities.
func (m *UserProjectMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserProjectMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserProjectMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserProject.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProjectName sets the "project_name" field.
func (m *UserProjectMutation) SetProjectName(s string) {
	m.project_name = &s
}

// ProjectName returns the value of the "project_name" field in the mutation.
func (m *UserProjectMutation) ProjectName() (r string, exists bool) {
	v := m.project_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectName returns the old "project_name" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldProjectName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectName: %w", err)
	}
	return oldValue.ProjectName, nil
}

// ResetProjectName resets all changes to the "project_name" field.
func (m *UserProjectMutation) ResetProjectName() {
	m.project_name = nil
}

// SetUserID sets the "user_id" field.
func (m *UserProjectMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserProjectMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserProjectMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userproject.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserProjectMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userproject.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserProjectMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userproject.FieldUserID)
}

// SetDescription sets the "description" field.
func (m *UserProjectMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserProjectMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserProjectMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[userproject.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserProjectMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[userproject.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserProjectMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, userproject.FieldDescription)
}

// SetFromDate sets the "from_date" field.
func (m *UserProjectMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *UserProjectMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ClearFromDate clears the value of the "from_date" field.
func (m *UserProjectMutation) ClearFromDate() {
	m.from_date = nil
	m.clearedFields[userproject.FieldFromDate] = struct{}{}
}

// FromDateCleared returns if the "from_date" field was cleared in this mutation.
func (m *UserProjectMutation) FromDateCleared() bool {
	_, ok := m.clearedFields[userproject.FieldFromDate]
	return ok
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *UserProjectMutation) ResetFromDate() {
	m.from_date = nil
	delete(m.clearedFields, userproject.FieldFromDate)
}

// SetToDate sets the "to_date" field.
func (m *UserProjectMutation) SetToDate(t time.Time) {
	m.to_date = &t
}

// ToDate returns the value of the "to_date" field in the mutation.
func (m *UserProjectMutation) ToDate() (r time.Time, exists bool) {
	v := m.to_date
	if v == nil {
		return
	}
	return *v, true
}

// OldToDate returns the old "to_date" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldToDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDate: %w", err)
	}
	return oldValue.ToDate, nil
}

// ClearToDate clears the value of the "to_date" field.
func (m *UserProjectMutation) ClearToDate() {
	m.to_date = nil
	m.clearedFields[userproject.FieldToDate] = struct{}{}
}

// ToDateCleared returns if the "to_date" field was cleared in this mutation.
func (m *UserProjectMutation) ToDateCleared() bool {
	_, ok := m.clearedFields[userproject.FieldToDate]
	return ok
}

// ResetToDate resets all changes to the "to_date" field.
func (m *UserProjectMutation) ResetToDate() {
	m.to_date = nil
	delete(m.clearedFields, userproject.FieldToDate)
}

// SetProjectLink sets the "project_link" field.
func (m *UserProjectMutation) SetProjectLink(s string) {
	m.project_link = &s
}

// ProjectLink returns the value of the "project_link" field in the mutation.
func (m *UserProjectMutation) ProjectLink() (r string, exists bool) {
	v := m.project_link
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectLink returns the old "project_link" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldProjectLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProjectLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProjectLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectLink: %w", err)
	}
	return oldValue.ProjectLink, nil
}

// ClearProjectLink clears the value of the "project_link" field.
func (m *UserProjectMutation) ClearProjectLink() {
	m.project_link = nil
	m.clearedFields[userproject.FieldProjectLink] = struct{}{}
}

// ProjectLinkCleared returns if the "project_link" field was cleared in this mutation.
func (m *UserProjectMutation) ProjectLinkCleared() bool {
	_, ok := m.clearedFields[userproject.FieldProjectLink]
	return ok
}

// ResetProjectLink resets all changes to the "project_link" field.
func (m *UserProjectMutation) ResetProjectLink() {
	m.project_link = nil
	delete(m.clearedFields, userproject.FieldProjectLink)
}

// SetTechnologies sets the "technologies" field.
func (m *UserProjectMutation) SetTechnologies(s string) {
	m.technologies = &s
}

// Technologies returns the value of the "technologies" field in the mutation.
func (m *UserProjectMutation) Technologies() (r string, exists bool) {
	v := m.technologies
	if v == nil {
		return
	}
	return *v, true
}

// OldTechnologies returns the old "technologies" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldTechnologies(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTechnologies is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTechnologies requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTechnologies: %w", err)
	}
	return oldValue.Technologies, nil
}

// ClearTechnologies clears the value of the "technologies" field.
func (m *UserProjectMutation) ClearTechnologies() {
	m.technologies = nil
	m.clearedFields[userproject.FieldTechnologies] = struct{}{}
}

// TechnologiesCleared returns if the "technologies" field was cleared in this mutation.
func (m *UserProjectMutation) TechnologiesCleared() bool {
	_, ok := m.clearedFields[userproject.FieldTechnologies]
	return ok
}

// ResetTechnologies resets all changes to the "technologies" field.
func (m *UserProjectMutation) ResetTechnologies() {
	m.technologies = nil
	delete(m.clearedFields, userproject.FieldTechnologies)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserProjectMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userproject.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserProjectMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userproject.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserProjectMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userproject.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserProjectMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserProjectMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserProject entity.
// If the UserProject object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserProjectMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserProjectMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userproject.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserProjectMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userproject.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserProjectMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userproject.FieldUpdatedAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserProjectMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userproject.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserProjectMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserProjectMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserProjectMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserProjectMutation builder.
func (m *UserProjectMutation) Where(ps ...predicate.UserProject) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserProjectMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserProjectMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserProject, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserProjectMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserProjectMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserProject).
func (m *UserProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserProjectMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.project_name != nil {
		fields = append(fields, userproject.FieldProjectName)
	}
	if m.user != nil {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.description != nil {
		fields = append(fields, userproject.FieldDescription)
	}
	if m.from_date != nil {
		fields = append(fields, userproject.FieldFromDate)
	}
	if m.to_date != nil {
		fields = append(fields, userproject.FieldToDate)
	}
	if m.project_link != nil {
		fields = append(fields, userproject.FieldProjectLink)
	}
	if m.technologies != nil {
		fields = append(fields, userproject.FieldTechnologies)
	}
	if m.created_at != nil {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userproject.FieldProjectName:
		return m.ProjectName()
	case userproject.FieldUserID:
		return m.UserID()
	case userproject.FieldDescription:
		return m.Description()
	case userproject.FieldFromDate:
		return m.FromDate()
	case userproject.FieldToDate:
		return m.ToDate()
	case userproject.FieldProjectLink:
		return m.ProjectLink()
	case userproject.FieldTechnologies:
		return m.Technologies()
	case userproject.FieldCreatedAt:
		return m.CreatedAt()
	case userproject.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userproject.FieldProjectName:
		return m.OldProjectName(ctx)
	case userproject.FieldUserID:
		return m.OldUserID(ctx)
	case userproject.FieldDescription:
		return m.OldDescription(ctx)
	case userproject.FieldFromDate:
		return m.OldFromDate(ctx)
	case userproject.FieldToDate:
		return m.OldToDate(ctx)
	case userproject.FieldProjectLink:
		return m.OldProjectLink(ctx)
	case userproject.FieldTechnologies:
		return m.OldTechnologies(ctx)
	case userproject.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userproject.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserProject field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userproject.FieldProjectName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectName(v)
		return nil
	case userproject.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userproject.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case userproject.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case userproject.FieldToDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDate(v)
		return nil
	case userproject.FieldProjectLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectLink(v)
		return nil
	case userproject.FieldTechnologies:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTechnologies(v)
		return nil
	case userproject.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userproject.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserProjectMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserProject numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userproject.FieldUserID) {
		fields = append(fields, userproject.FieldUserID)
	}
	if m.FieldCleared(userproject.FieldDescription) {
		fields = append(fields, userproject.FieldDescription)
	}
	if m.FieldCleared(userproject.FieldFromDate) {
		fields = append(fields, userproject.FieldFromDate)
	}
	if m.FieldCleared(userproject.FieldToDate) {
		fields = append(fields, userproject.FieldToDate)
	}
	if m.FieldCleared(userproject.FieldProjectLink) {
		fields = append(fields, userproject.FieldProjectLink)
	}
	if m.FieldCleared(userproject.FieldTechnologies) {
		fields = append(fields, userproject.FieldTechnologies)
	}
	if m.FieldCleared(userproject.FieldCreatedAt) {
		fields = append(fields, userproject.FieldCreatedAt)
	}
	if m.FieldCleared(userproject.FieldUpdatedAt) {
		fields = append(fields, userproject.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserProjectMutation) ClearField(name string) error {
	switch name {
	case userproject.FieldUserID:
		m.ClearUserID()
		return nil
	case userproject.FieldDescription:
		m.ClearDescription()
		return nil
	case userproject.FieldFromDate:
		m.ClearFromDate()
		return nil
	case userproject.FieldToDate:
		m.ClearToDate()
		return nil
	case userproject.FieldProjectLink:
		m.ClearProjectLink()
		return nil
	case userproject.FieldTechnologies:
		m.ClearTechnologies()
		return nil
	case userproject.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userproject.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProject nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserProjectMutation) ResetField(name string) error {
	switch name {
	case userproject.FieldProjectName:
		m.ResetProjectName()
		return nil
	case userproject.FieldUserID:
		m.ResetUserID()
		return nil
	case userproject.FieldDescription:
		m.ResetDescription()
		return nil
	case userproject.FieldFromDate:
		m.ResetFromDate()
		return nil
	case userproject.FieldToDate:
		m.ResetToDate()
		return nil
	case userproject.FieldProjectLink:
		m.ResetProjectLink()
		return nil
	case userproject.FieldTechnologies:
		m.ResetTechnologies()
		return nil
	case userproject.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userproject.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserProject field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userproject.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userproject.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserProjectMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userproject.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case userproject.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserProjectMutation) ClearEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserProject unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserProjectMutation) ResetEdge(name string) error {
	switch name {
	case userproject.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserProject edge %s", name)
}

// UserServiceMutation represents an operation that mutates the UserService nodes in the graph.
type UserServiceMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uint
	service_name        *string
	service_description *string
	service_icon        *string
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	user                *uint
	cleareduser         bool
	done                bool
	oldValue            func(context.Context) (*UserService, error)
	predicates          []predicate.UserService
}

var _ ent.Mutation = (*UserServiceMutation)(nil)

// userserviceOption allows management of the mutation configuration using functional options.
type userserviceOption func(*UserServiceMutation)

// newUserServiceMutation creates new mutation for the UserService entity.
func newUserServiceMutation(c config, op Op, opts ...userserviceOption) *UserServiceMutation {
	m := &UserServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeUserService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserServiceID sets the ID field of the mutation.
func withUserServiceID(id uint) userserviceOption {
	return func(m *UserServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *UserService
		)
		m.oldValue = func(ctx context.Context) (*UserService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserService sets the old UserService of the mutation.
func withUserService(node *UserService) userserviceOption {
	return func(m *UserServiceMutation) {
		m.oldValue = func(context.Context) (*UserService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserService entities.
func (m *UserServiceMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserServiceMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserServiceMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetServiceName sets the "service_name" field.
func (m *UserServiceMutation) SetServiceName(s string) {
	m.service_name = &s
}

// ServiceName returns the value of the "service_name" field in the mutation.
func (m *UserServiceMutation) ServiceName() (r string, exists bool) {
	v := m.service_name
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceName returns the old "service_name" field's value of the UserService entity.
// If the UserService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserServiceMutation) OldServiceName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceName: %w", err)
	}
	return oldValue.ServiceName, nil
}

// ClearServiceName clears the value of the "service_name" field.
func (m *UserServiceMutation) ClearServiceName() {
	m.service_name = nil
	m.clearedFields[userservice.FieldServiceName] = struct{}{}
}

// ServiceNameCleared returns if the "service_name" field was cleared in this mutation.
func (m *UserServiceMutation) ServiceNameCleared() bool {
	_, ok := m.clearedFields[userservice.FieldServiceName]
	return ok
}

// ResetServiceName resets all changes to the "service_name" field.
func (m *UserServiceMutation) ResetServiceName() {
	m.service_name = nil
	delete(m.clearedFields, userservice.FieldServiceName)
}

// SetServiceDescription sets the "service_description" field.
func (m *UserServiceMutation) SetServiceDescription(s string) {
	m.service_description = &s
}

// ServiceDescription returns the value of the "service_description" field in the mutation.
func (m *UserServiceMutation) ServiceDescription() (r string, exists bool) {
	v := m.service_description
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceDescription returns the old "service_description" field's value of the UserService entity.
// If the UserService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserServiceMutation) OldServiceDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceDescription: %w", err)
	}
	return oldValue.ServiceDescription, nil
}

// ClearServiceDescription clears the value of the "service_description" field.
func (m *UserServiceMutation) ClearServiceDescription() {
	m.service_description = nil
	m.clearedFields[userservice.FieldServiceDescription] = struct{}{}
}

// ServiceDescriptionCleared returns if the "service_description" field was cleared in this mutation.
func (m *UserServiceMutation) ServiceDescriptionCleared() bool {
	_, ok := m.clearedFields[userservice.FieldServiceDescription]
	return ok
}

// ResetServiceDescription resets all changes to the "service_description" field.
func (m *UserServiceMutation) ResetServiceDescription() {
	m.service_description = nil
	delete(m.clearedFields, userservice.FieldServiceDescription)
}

// SetServiceIcon sets the "service_icon" field.
func (m *UserServiceMutation) SetServiceIcon(s string) {
	m.service_icon = &s
}

// ServiceIcon returns the value of the "service_icon" field in the mutation.
func (m *UserServiceMutation) ServiceIcon() (r string, exists bool) {
	v := m.service_icon
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceIcon returns the old "service_icon" field's value of the UserService entity.
// If the UserService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserServiceMutation) OldServiceIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceIcon: %w", err)
	}
	return oldValue.ServiceIcon, nil
}

// ClearServiceIcon clears the value of the "service_icon" field.
func (m *UserServiceMutation) ClearServiceIcon() {
	m.service_icon = nil
	m.clearedFields[userservice.FieldServiceIcon] = struct{}{}
}

// ServiceIconCleared returns if the "service_icon" field was cleared in this mutation.
func (m *UserServiceMutation) ServiceIconCleared() bool {
	_, ok := m.clearedFields[userservice.FieldServiceIcon]
	return ok
}

// ResetServiceIcon resets all changes to the "service_icon" field.
func (m *UserServiceMutation) ResetServiceIcon() {
	m.service_icon = nil
	delete(m.clearedFields, userservice.FieldServiceIcon)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserService entity.
// If the UserService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserServiceMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userservice.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserServiceMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userservice.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserServiceMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userservice.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserService entity.
// If the UserService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserServiceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userservice.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserServiceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userservice.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userservice.FieldUpdatedAt)
}

// SetUserID sets the "user_id" field.
func (m *UserServiceMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserServiceMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserService entity.
// If the UserService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserServiceMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserServiceMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userservice.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserServiceMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userservice.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserServiceMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userservice.FieldUserID)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserServiceMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userservice.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserServiceMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserServiceMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserServiceMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserServiceMutation builder.
func (m *UserServiceMutation) Where(ps ...predicate.UserService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserService).
func (m *UserServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserServiceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.service_name != nil {
		fields = append(fields, userservice.FieldServiceName)
	}
	if m.service_description != nil {
		fields = append(fields, userservice.FieldServiceDescription)
	}
	if m.service_icon != nil {
		fields = append(fields, userservice.FieldServiceIcon)
	}
	if m.created_at != nil {
		fields = append(fields, userservice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userservice.FieldUpdatedAt)
	}
	if m.user != nil {
		fields = append(fields, userservice.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userservice.FieldServiceName:
		return m.ServiceName()
	case userservice.FieldServiceDescription:
		return m.ServiceDescription()
	case userservice.FieldServiceIcon:
		return m.ServiceIcon()
	case userservice.FieldCreatedAt:
		return m.CreatedAt()
	case userservice.FieldUpdatedAt:
		return m.UpdatedAt()
	case userservice.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userservice.FieldServiceName:
		return m.OldServiceName(ctx)
	case userservice.FieldServiceDescription:
		return m.OldServiceDescription(ctx)
	case userservice.FieldServiceIcon:
		return m.OldServiceIcon(ctx)
	case userservice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userservice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userservice.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown UserService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userservice.FieldServiceName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceName(v)
		return nil
	case userservice.FieldServiceDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceDescription(v)
		return nil
	case userservice.FieldServiceIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceIcon(v)
		return nil
	case userservice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userservice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userservice.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown UserService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserServiceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserServiceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userservice.FieldServiceName) {
		fields = append(fields, userservice.FieldServiceName)
	}
	if m.FieldCleared(userservice.FieldServiceDescription) {
		fields = append(fields, userservice.FieldServiceDescription)
	}
	if m.FieldCleared(userservice.FieldServiceIcon) {
		fields = append(fields, userservice.FieldServiceIcon)
	}
	if m.FieldCleared(userservice.FieldCreatedAt) {
		fields = append(fields, userservice.FieldCreatedAt)
	}
	if m.FieldCleared(userservice.FieldUpdatedAt) {
		fields = append(fields, userservice.FieldUpdatedAt)
	}
	if m.FieldCleared(userservice.FieldUserID) {
		fields = append(fields, userservice.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserServiceMutation) ClearField(name string) error {
	switch name {
	case userservice.FieldServiceName:
		m.ClearServiceName()
		return nil
	case userservice.FieldServiceDescription:
		m.ClearServiceDescription()
		return nil
	case userservice.FieldServiceIcon:
		m.ClearServiceIcon()
		return nil
	case userservice.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userservice.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userservice.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown UserService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserServiceMutation) ResetField(name string) error {
	switch name {
	case userservice.FieldServiceName:
		m.ResetServiceName()
		return nil
	case userservice.FieldServiceDescription:
		m.ResetServiceDescription()
		return nil
	case userservice.FieldServiceIcon:
		m.ResetServiceIcon()
		return nil
	case userservice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userservice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userservice.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown UserService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userservice.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userservice.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserServiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userservice.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case userservice.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserServiceMutation) ClearEdge(name string) error {
	switch name {
	case userservice.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserServiceMutation) ResetEdge(name string) error {
	switch name {
	case userservice.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserService edge %s", name)
}

// UserSkillAssociationMutation represents an operation that mutates the UserSkillAssociation nodes in the graph.
type UserSkillAssociationMutation struct {
	config
	op            Op
	typ           string
	id            *uint
	created_at    *time.Time
	updated_at    *time.Time
	percentage    *int32
	addpercentage *int32
	clearedFields map[string]struct{}
	skill         *uint
	clearedskill  bool
	user          *uint
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserSkillAssociation, error)
	predicates    []predicate.UserSkillAssociation
}

var _ ent.Mutation = (*UserSkillAssociationMutation)(nil)

// userskillassociationOption allows management of the mutation configuration using functional options.
type userskillassociationOption func(*UserSkillAssociationMutation)

// newUserSkillAssociationMutation creates new mutation for the UserSkillAssociation entity.
func newUserSkillAssociationMutation(c config, op Op, opts ...userskillassociationOption) *UserSkillAssociationMutation {
	m := &UserSkillAssociationMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSkillAssociation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSkillAssociationID sets the ID field of the mutation.
func withUserSkillAssociationID(id uint) userskillassociationOption {
	return func(m *UserSkillAssociationMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSkillAssociation
		)
		m.oldValue = func(ctx context.Context) (*UserSkillAssociation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSkillAssociation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSkillAssociation sets the old UserSkillAssociation of the mutation.
func withUserSkillAssociation(node *UserSkillAssociation) userskillassociationOption {
	return func(m *UserSkillAssociationMutation) {
		m.oldValue = func(context.Context) (*UserSkillAssociation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSkillAssociationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSkillAssociationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSkillAssociation entities.
func (m *UserSkillAssociationMutation) SetID(id uint) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSkillAssociationMutation) ID() (id uint, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSkillAssociationMutation) IDs(ctx context.Context) ([]uint, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uint{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSkillAssociation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSkillAssociationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSkillAssociationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSkillAssociation entity.
// If the UserSkillAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSkillAssociationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserSkillAssociationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[userskillassociation.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserSkillAssociationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[userskillassociation.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSkillAssociationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, userskillassociation.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSkillAssociationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSkillAssociationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSkillAssociation entity.
// If the UserSkillAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSkillAssociationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserSkillAssociationMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[userskillassociation.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserSkillAssociationMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[userskillassociation.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSkillAssociationMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, userskillassociation.FieldUpdatedAt)
}

// SetPercentage sets the "percentage" field.
func (m *UserSkillAssociationMutation) SetPercentage(i int32) {
	m.percentage = &i
	m.addpercentage = nil
}

// Percentage returns the value of the "percentage" field in the mutation.
func (m *UserSkillAssociationMutation) Percentage() (r int32, exists bool) {
	v := m.percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldPercentage returns the old "percentage" field's value of the UserSkillAssociation entity.
// If the UserSkillAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSkillAssociationMutation) OldPercentage(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPercentage: %w", err)
	}
	return oldValue.Percentage, nil
}

// AddPercentage adds i to the "percentage" field.
func (m *UserSkillAssociationMutation) AddPercentage(i int32) {
	if m.addpercentage != nil {
		*m.addpercentage += i
	} else {
		m.addpercentage = &i
	}
}

// AddedPercentage returns the value that was added to the "percentage" field in this mutation.
func (m *UserSkillAssociationMutation) AddedPercentage() (r int32, exists bool) {
	v := m.addpercentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearPercentage clears the value of the "percentage" field.
func (m *UserSkillAssociationMutation) ClearPercentage() {
	m.percentage = nil
	m.addpercentage = nil
	m.clearedFields[userskillassociation.FieldPercentage] = struct{}{}
}

// PercentageCleared returns if the "percentage" field was cleared in this mutation.
func (m *UserSkillAssociationMutation) PercentageCleared() bool {
	_, ok := m.clearedFields[userskillassociation.FieldPercentage]
	return ok
}

// ResetPercentage resets all changes to the "percentage" field.
func (m *UserSkillAssociationMutation) ResetPercentage() {
	m.percentage = nil
	m.addpercentage = nil
	delete(m.clearedFields, userskillassociation.FieldPercentage)
}

// SetUserID sets the "user_id" field.
func (m *UserSkillAssociationMutation) SetUserID(u uint) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSkillAssociationMutation) UserID() (r uint, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSkillAssociation entity.
// If the UserSkillAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSkillAssociationMutation) OldUserID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *UserSkillAssociationMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[userskillassociation.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *UserSkillAssociationMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[userskillassociation.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSkillAssociationMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, userskillassociation.FieldUserID)
}

// SetSkillID sets the "skill_id" field.
func (m *UserSkillAssociationMutation) SetSkillID(u uint) {
	m.skill = &u
}

// SkillID returns the value of the "skill_id" field in the mutation.
func (m *UserSkillAssociationMutation) SkillID() (r uint, exists bool) {
	v := m.skill
	if v == nil {
		return
	}
	return *v, true
}

// OldSkillID returns the old "skill_id" field's value of the UserSkillAssociation entity.
// If the UserSkillAssociation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSkillAssociationMutation) OldSkillID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkillID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkillID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkillID: %w", err)
	}
	return oldValue.SkillID, nil
}

// ClearSkillID clears the value of the "skill_id" field.
func (m *UserSkillAssociationMutation) ClearSkillID() {
	m.skill = nil
	m.clearedFields[userskillassociation.FieldSkillID] = struct{}{}
}

// SkillIDCleared returns if the "skill_id" field was cleared in this mutation.
func (m *UserSkillAssociationMutation) SkillIDCleared() bool {
	_, ok := m.clearedFields[userskillassociation.FieldSkillID]
	return ok
}

// ResetSkillID resets all changes to the "skill_id" field.
func (m *UserSkillAssociationMutation) ResetSkillID() {
	m.skill = nil
	delete(m.clearedFields, userskillassociation.FieldSkillID)
}

// ClearSkill clears the "skill" edge to the Skill entity.
func (m *UserSkillAssociationMutation) ClearSkill() {
	m.clearedskill = true
	m.clearedFields[userskillassociation.FieldSkillID] = struct{}{}
}

// SkillCleared reports if the "skill" edge to the Skill entity was cleared.
func (m *UserSkillAssociationMutation) SkillCleared() bool {
	return m.SkillIDCleared() || m.clearedskill
}

// SkillIDs returns the "skill" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SkillID instead. It exists only for internal usage by the builders.
func (m *UserSkillAssociationMutation) SkillIDs() (ids []uint) {
	if id := m.skill; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSkill resets all changes to the "skill" edge.
func (m *UserSkillAssociationMutation) ResetSkill() {
	m.skill = nil
	m.clearedskill = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSkillAssociationMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userskillassociation.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSkillAssociationMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSkillAssociationMutation) UserIDs() (ids []uint) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSkillAssociationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSkillAssociationMutation builder.
func (m *UserSkillAssociationMutation) Where(ps ...predicate.UserSkillAssociation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSkillAssociationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSkillAssociationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSkillAssociation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSkillAssociationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSkillAssociationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSkillAssociation).
func (m *UserSkillAssociationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSkillAssociationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, userskillassociation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userskillassociation.FieldUpdatedAt)
	}
	if m.percentage != nil {
		fields = append(fields, userskillassociation.FieldPercentage)
	}
	if m.user != nil {
		fields = append(fields, userskillassociation.FieldUserID)
	}
	if m.skill != nil {
		fields = append(fields, userskillassociation.FieldSkillID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSkillAssociationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userskillassociation.FieldCreatedAt:
		return m.CreatedAt()
	case userskillassociation.FieldUpdatedAt:
		return m.UpdatedAt()
	case userskillassociation.FieldPercentage:
		return m.Percentage()
	case userskillassociation.FieldUserID:
		return m.UserID()
	case userskillassociation.FieldSkillID:
		return m.SkillID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSkillAssociationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userskillassociation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userskillassociation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userskillassociation.FieldPercentage:
		return m.OldPercentage(ctx)
	case userskillassociation.FieldUserID:
		return m.OldUserID(ctx)
	case userskillassociation.FieldSkillID:
		return m.OldSkillID(ctx)
	}
	return nil, fmt.Errorf("unknown UserSkillAssociation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSkillAssociationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userskillassociation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userskillassociation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userskillassociation.FieldPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPercentage(v)
		return nil
	case userskillassociation.FieldUserID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userskillassociation.FieldSkillID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkillID(v)
		return nil
	}
	return fmt.Errorf("unknown UserSkillAssociation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSkillAssociationMutation) AddedFields() []string {
	var fields []string
	if m.addpercentage != nil {
		fields = append(fields, userskillassociation.FieldPercentage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSkillAssociationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userskillassociation.FieldPercentage:
		return m.AddedPercentage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSkillAssociationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userskillassociation.FieldPercentage:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPercentage(v)
		return nil
	}
	return fmt.Errorf("unknown UserSkillAssociation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSkillAssociationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userskillassociation.FieldCreatedAt) {
		fields = append(fields, userskillassociation.FieldCreatedAt)
	}
	if m.FieldCleared(userskillassociation.FieldUpdatedAt) {
		fields = append(fields, userskillassociation.FieldUpdatedAt)
	}
	if m.FieldCleared(userskillassociation.FieldPercentage) {
		fields = append(fields, userskillassociation.FieldPercentage)
	}
	if m.FieldCleared(userskillassociation.FieldUserID) {
		fields = append(fields, userskillassociation.FieldUserID)
	}
	if m.FieldCleared(userskillassociation.FieldSkillID) {
		fields = append(fields, userskillassociation.FieldSkillID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSkillAssociationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSkillAssociationMutation) ClearField(name string) error {
	switch name {
	case userskillassociation.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case userskillassociation.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case userskillassociation.FieldPercentage:
		m.ClearPercentage()
		return nil
	case userskillassociation.FieldUserID:
		m.ClearUserID()
		return nil
	case userskillassociation.FieldSkillID:
		m.ClearSkillID()
		return nil
	}
	return fmt.Errorf("unknown UserSkillAssociation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSkillAssociationMutation) ResetField(name string) error {
	switch name {
	case userskillassociation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userskillassociation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userskillassociation.FieldPercentage:
		m.ResetPercentage()
		return nil
	case userskillassociation.FieldUserID:
		m.ResetUserID()
		return nil
	case userskillassociation.FieldSkillID:
		m.ResetSkillID()
		return nil
	}
	return fmt.Errorf("unknown UserSkillAssociation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSkillAssociationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.skill != nil {
		edges = append(edges, userskillassociation.EdgeSkill)
	}
	if m.user != nil {
		edges = append(edges, userskillassociation.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSkillAssociationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userskillassociation.EdgeSkill:
		if id := m.skill; id != nil {
			return []ent.Value{*id}
		}
	case userskillassociation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSkillAssociationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSkillAssociationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSkillAssociationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedskill {
		edges = append(edges, userskillassociation.EdgeSkill)
	}
	if m.cleareduser {
		edges = append(edges, userskillassociation.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSkillAssociationMutation) EdgeCleared(name string) bool {
	switch name {
	case userskillassociation.EdgeSkill:
		return m.clearedskill
	case userskillassociation.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSkillAssociationMutation) ClearEdge(name string) error {
	switch name {
	case userskillassociation.EdgeSkill:
		m.ClearSkill()
		return nil
	case userskillassociation.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSkillAssociation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSkillAssociationMutation) ResetEdge(name string) error {
	switch name {
	case userskillassociation.EdgeSkill:
		m.ResetSkill()
		return nil
	case userskillassociation.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSkillAssociation edge %s", name)
}
